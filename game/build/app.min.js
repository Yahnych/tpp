(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Entity = function () {
    // angle = 0 - up, 1 - right, 2 - down, 3 - left
    function Entity(cx, cy) {
        var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
        var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var vel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

        _classCallCheck(this, Entity);

        this.cx = cx;
        this.cy = cy;
        this.size = size | 0;
        this.angle = angle | 0;
        this.vel = vel;
    }

    _createClass(Entity, [{
        key: "move",
        value: function move(delta) {
            var sina = [-1, 0, 1, 0];
            var cosa = [0, 1, 0, -1];
            var koef = 80.0 / 1024.0;

            var dx = cosa[this.angle] * this.vel * delta * koef;
            var dy = sina[this.angle] * this.vel * delta * koef;
            this.cx += dx;
            this.cy += dy;
        }
    }]);

    return Entity;
}();

exports.default = Entity;
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ref;

var _utils = require("./utils");

var _level = require("./level");

var _level2 = _interopRequireDefault(_level);

var _entity = require("./entity");

var _entity2 = _interopRequireDefault(_entity);

var _tank = require("./tank");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var keyToAngle = [{
    38: 0, // UP
    39: 1, // RIGHT
    40: 2, // DOWN
    37: 3 // LEFT
}, (_ref = {}, _defineProperty(_ref, "W".charCodeAt(0), 0), _defineProperty(_ref, "D".charCodeAt(0), 1), _defineProperty(_ref, "S".charCodeAt(0), 2), _defineProperty(_ref, "A".charCodeAt(0), 3), _ref)];
var maskToAngle = {
    1: 0,
    2: 1,
    4: 2,
    8: 3
};

var Game = function () {
    function Game(difficulty, canvas) {
        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "level";

        _classCallCheck(this, Game);

        // common game settings
        this.currentDifficulty = difficulty;
        this.currentLevel = 1;
        this.canvas = canvas;
        this.mode = mode;

        var _getMapSize = (0, _utils.getMapSize)(),
            mapWidth = _getMapSize.mapWidth,
            mapHeight = _getMapSize.mapHeight;

        this.mapWidth = mapWidth - 2; // board
        this.mapHeight = mapHeight - 2; // board
        this.lastTime = Date.now();

        // player settings
        this.keyMask = [0, 0];

        this.eagle = new _entity2.default(this.mapWidth * 0.5, this.mapHeight - 1);
        this.players = [new _tank.Tank(10, 10, _tank.TANK.TANK1), new _tank.Tank(15, 10, _tank.TANK.TANK2)];

        this.newLevel();
    }

    _createClass(Game, [{
        key: "newLevel",
        value: function newLevel() {
            var levelName = "levels/" + this.mode;
            if (this.mode === "level") levelName += "" + this.currentLevel;

            this.level = new _level2.default(levelName, this.canvas);
        }
    }, {
        key: "update",
        value: function update() {
            if (!this.level.ready()) return;

            var time = Date.now();
            var delta = time - this.lastTime;
            this.lastTime = time;

            // clearing
            this.level.clearEntity(this.eagle);
            this.players[0].clear(this.level);
            this.players[1].clear(this.level);

            // updating
            this.players[0].update(delta);
            this.players[1].update(delta);

            // drawing
            this.level.drawEntity(this.eagle, this.level.textures.eagle);
            this.players[0].draw(this.level);
            this.players[1].draw(this.level);
        }
    }, {
        key: "pause",
        value: function pause() {}
    }, {
        key: "onkeydown",
        value: function onkeydown(key) {
            for (var p = 0; p < 2; p++) {
                if (this.players[p] && key in keyToAngle[p]) {
                    this.players[p].angle = keyToAngle[p][key];
                    this.players[p].vel = 0.05;
                    this.keyMask[p] |= 1 << keyToAngle[p][key];
                }
            }
        }
    }, {
        key: "onkeyup",
        value: function onkeyup(key) {
            for (var p = 0; p < 2; p++) {
                if (this.players[p]) {
                    if (key in keyToAngle[p]) {
                        this.keyMask[p] ^= 1 << keyToAngle[p][key];
                    }
                    if (this.keyMask[p] in maskToAngle) {
                        this.players[p].angle = maskToAngle[this.keyMask[p]];
                    } else {
                        this.players[p].vel = 0;
                    }
                }
            }
        }
    }]);

    return Game;
}();

exports.default = Game;
},{"./entity":1,"./level":5,"./tank":7,"./utils":8}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("../utils");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lerp(a, b, t) {
    return a * (1 - t) + b * t;
}

function norm(x) {
    var a = 1 / Math.sqrt(2 * Math.PI);
    var b = -x * x / 2;
    return a * Math.exp(b);
}

var SimpleBuffer = function () {
    function SimpleBuffer(size) {
        _classCallCheck(this, SimpleBuffer);

        this.data = new Float32Array(size * size);
        this.size = size;
        this.data.fill(0.0);
    }

    _createClass(SimpleBuffer, [{
        key: "getData",
        value: function getData(x, y) {
            if (x < 0 || x > this.size - 1) return 0.0;
            if (y < 0 || y > this.size - 1) return 0.0;
            return this.data[y * this.size + x | 0];
        }
    }, {
        key: "setData",
        value: function setData(x, y, val) {
            if (x < 0 || x > this.size - 1) return;
            if (y < 0 || y > this.size - 1) return;
            this.data[y * this.size + x | 0] = val;
        }
    }, {
        key: "getColor",
        value: function getColor() {
            var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [255, 255, 255];
            var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            console.assert(!mask || mask.size === this.size, "Require same size");
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = col[0] * this.data[i] | 0;
                imageData.data[4 * i + 1] = col[1] * this.data[i] | 0;
                imageData.data[4 * i + 2] = col[2] * this.data[i] | 0;
                imageData.data[4 * i + 3] = mask ? mask.data[i] * 255 | 0 : 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColor2",
        value: function getColor2() {
            var col0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
            var col1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 255, 255];
            var mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            console.assert(!mask || mask.size === this.size, "Require same size");
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = (0, _utils.clamp)(lerp(col0[0], col1[0], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 1] = (0, _utils.clamp)(lerp(col0[1], col1[1], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 2] = (0, _utils.clamp)(lerp(col0[2], col1[2], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 3] = mask ? mask.data[i] * 255 | 0 : 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColorLerp",
        value: function getColorLerp(img0, img1) {
            console.assert(img0.width === img1.width, "Require same image");
            console.assert(img0.height === img1.height, "Require same image");
            console.assert(img0.width === this.size, "Require same image");
            console.assert(img0.height === this.size, "Require same image");

            var data0 = img0.getContext("2d").getImageData(0, 0, this.size, this.size).data;
            var data1 = img1.getContext("2d").getImageData(0, 0, this.size, this.size).data;
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = lerp(data0[4 * i + 0], data1[4 * i + 0], this.data[i]) | 0;
                imageData.data[4 * i + 1] = lerp(data0[4 * i + 1], data1[4 * i + 1], this.data[i]) | 0;
                imageData.data[4 * i + 2] = lerp(data0[4 * i + 2], data1[4 * i + 2], this.data[i]) | 0;
                imageData.data[4 * i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "perlin",
        value: function perlin(startFreq, koef) {
            var _this = this;

            var time = Date.now();
            var extrem = function extrem(freq, ampl) {
                var dispersion = function dispersion(rad) {
                    return (0, _utils.rand)(0, rad);
                };

                var ret = new Array(freq * freq);
                for (var i = 0; i < freq * freq; i++) {
                    ret[i] = dispersion(ampl);
                }
                return ret;
            };
            var cosLerp = function cosLerp(a, b, t) {
                var ft = t * Math.PI;
                var f = (1 - Math.cos(ft)) * 0.5;
                return a * (1 - f) + b * f;
            };

            var ampl = 1;
            var freq = startFreq;

            var _loop = function _loop() {
                var buf = extrem(freq, ampl);
                var bufData = function bufData(x, y) {
                    return buf[y * freq + x | 0];
                };

                for (var j = 0; j < _this.size; j++) {
                    for (var i = 0; i < _this.size; i++) {
                        var x = i * freq / _this.size | 0;
                        var y = j * freq / _this.size | 0;
                        var tx = i * freq / _this.size - x;
                        var ty = j * freq / _this.size - y;
                        var x1 = bufData(x, y);
                        var oldX = x;
                        x++;
                        if (x > freq - 1) x = 0;
                        var x2 = bufData(x, y);
                        var xx = cosLerp(x1, x2, tx);

                        y++;
                        if (y > freq - 1) y = 0;
                        var y1 = bufData(oldX, y);
                        var y2 = bufData(x, y);
                        var yy = cosLerp(y1, y2, tx);
                        var h = cosLerp(xx, yy, ty);

                        _this.data[_this.size * j + i | 0] += h;
                    }
                }
                freq *= 2;
                ampl *= koef;
            };

            do {
                _loop();
            } while (freq < this.size);

            console.log("Perlin noise = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normalize",
        value: function normalize(a, b) {
            var time = Date.now();
            var min = this.data[0];
            var max = this.data[0];
            for (var i = 1; i < this.size * this.size; i++) {
                max = Math.max(max, this.data[i]);
                min = Math.min(min, this.data[i]);
            }
            var k = (b - a) / (max - min);
            for (var _i = 0; _i < this.size * this.size; _i++) {
                this.data[_i] = (this.data[_i] - min) * k + a;
            }
            console.log("Normalize = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forEach",
        value: function forEach(fun) {
            var time = Date.now();
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], i, j);
                }
            }
            console.log("For each = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forBuf",
        value: function forBuf(buf, fun) {
            var time = Date.now();
            console.assert(this.size === buf.size, "Sizes of buffers must be equal");
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], buf.data[ind], i, j);
                }
            }
            console.log("For buffer = ", Date.now() - time);
            return this;
        }
    }, {
        key: "clamp",
        value: function clamp(a, b) {
            var time = Date.now();
            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = (0, _utils.clamp)(this.data[i], a, b);
            }
            console.log("Clamp = ", Date.now() - time);
            return this;
        }
    }, {
        key: "gaussianFast",
        value: function gaussianFast(srcBuf, radius, dir) {
            var time = Date.now();
            console.assert(this.size === srcBuf.size, "Sizes of buffers must be equal");
            console.assert(this !== srcBuf, "Source buffer must does not be same with this");

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var kol = 0.0;
                    var sum = 0.0;
                    for (var p = -radius; p <= radius; p++) {
                        var x = i + dir[0] * p;
                        var y = j + dir[1] * p;

                        var sx = (x - i) / radius;
                        var sy = (y - j) / radius;
                        var r = Math.sqrt(sx * sx + sy * sy);
                        var koef = norm(r * 3);
                        kol += koef;

                        if (x < 0) x += this.size;
                        if (y < 0) y += this.size;
                        if (x > this.size - 1) x -= this.size;
                        if (y > this.size - 1) y -= this.size;

                        sum += koef * srcBuf.data[y * this.size + x | 0];
                    }
                    var ind = i + j * this.size | 0;
                    this.data[ind] = sum / kol;
                }
            }
            console.log("Gaussian fast = ", Date.now() - time);
        }
    }, {
        key: "gaussian",
        value: function gaussian(radius) {
            var blur = new SimpleBuffer(this.size);
            blur.gaussianFast(this, radius, [1, 0]);
            this.gaussianFast(blur, radius, [0, 1]);
            return this;
        }
    }, {
        key: "copy",
        value: function copy(src) {
            var time = Date.now();
            console.assert(this.size === src.size, "Sizes of buffers must be equal");
            console.assert(this !== src, "Source buffer must does not be same with this");

            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = src.data[i];
            }

            console.log("Copy = ", Date.now() - time);
            return this;
        }
    }, {
        key: "bresenham",
        value: function bresenham(x0, y0, x1, y1, val) {
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var sx = x0 < x1 ? 1 : -1;
            var sy = y0 < y1 ? 1 : -1;
            var err = (dx > dy ? dx : -dy) / 2;
            var x = x0;
            var y = y0;

            for (;;) {
                this.setData(x, y, val);
                if (x === x1 && y === y1) break;
                var e2 = err;
                if (e2 > -dx) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dy) {
                    err += dx;
                    y += sy;
                }
            }
            return this;
        }
    }, {
        key: "differential",
        value: function differential(fun) {
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var nx = i + 1;
                    var ny = j + 1;
                    if (nx > this.size - 1) nx = 0;
                    if (ny > this.size - 1) ny = 0;
                    var ind00 = j * this.size + i;
                    var ind01 = ny * this.size + i;
                    var ind10 = j * this.size + nx;
                    var col00 = this.data[ind00];
                    var col01 = this.data[ind01];
                    var col10 = this.data[ind10];
                    var dx = (col10 - col00) * 0.5;
                    var dy = (col01 - col00) * 0.5;
                    fun(ind00, dx, dy);
                }
            }
        }
    }, {
        key: "diff",
        value: function diff(dir) {
            var _this2 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this2.data[ind] = dx * dir[0] + dy * dir[1];
            });

            console.log("Differential", Date.now() - time);
            return this;
        }
    }, {
        key: "diffFree",
        value: function diffFree() {
            var _this3 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this3.data[ind] = Math.sqrt(dx * dx + dy * dy);
            });

            console.log("Differential free", Date.now() - time);
            return this;
        }
    }, {
        key: "brick",
        value: function brick(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                var startY = brickY * brickHeight | 0;
                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var color = Math.random();
                    var X = startX + brickX * brickWidth | 0;
                    for (var j = startY; j < startY + brickHeight; j++) {
                        if (j > this.size - 1) break;
                        for (var i = X; i < X + brickWidth; i++) {
                            var x = i < 0 ? this.size + i : i;
                            this.data[j * this.size + x] = color;
                        }
                    }
                }
            }

            console.log("Brick generate", Date.now() - time);
            return this;
        }
    }, {
        key: "brickMask",
        value: function brickMask(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var y = brickY * brickHeight | 0;
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                this.bresenham(0, y, this.size, y, 1);

                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var x = startX + brickX * brickWidth | 0;
                    if (x < 0) x += this.size;
                    this.bresenham(x, y, x, y + brickHeight | 0, 1);
                }
            }

            console.log("Brick mask generate", Date.now() - time);
            return this;
        }
    }, {
        key: "normDist",
        value: function normDist(rad) {
            var time = Date.now();

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var x = (i - this.size * 0.5) / (rad * this.size * 0.5);
                    var y = (j - this.size * 0.5) / (rad * this.size * 0.5);
                    var r = Math.sqrt(x * x + y * y);
                    var koef = norm(r * 3);
                    this.data[j * this.size + i] = koef;
                }
            }

            console.log("Normal distribution = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normSquare",
        value: function normSquare(minRad, rad) {
            var time = Date.now();

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var x = (i - this.size * 0.5) / (this.size * 0.5);
                    var y = (j - this.size * 0.5) / (this.size * 0.5);
                    var r = 0;
                    if (Math.abs(x) > minRad && Math.abs(y) > minRad) {
                        var sx = Math.abs(x) - minRad;
                        var sy = Math.abs(y) - minRad;
                        r = Math.sqrt(sx * sx + sy * sy);
                    } else if (Math.abs(x) > minRad) r = Math.abs(x) - minRad;else if (Math.abs(y) > minRad) r = Math.abs(y) - minRad;
                    r /= rad;
                    var koef = norm(r * 3);
                    this.data[j * this.size + i] = koef;
                }
            }

            console.log("Normal distribution for square pattern = ", Date.now() - time);
            return this;
        }
    }]);

    return SimpleBuffer;
}();

exports.default = SimpleBuffer;
},{"../utils":8}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _buffer = require("./buffer");

var _buffer2 = _interopRequireDefault(_buffer);

var _utils = require("../utils");

var _tank = require("../tank");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GenTextures = function GenTextures(tileSize) {
    var _colors,
        _tankBodies,
        _tankTurret,
        _tankTrack,
        _this = this;

    _classCallCheck(this, GenTextures);

    // ground
    var ground = new _buffer2.default(tileSize * 8);
    this.ground = ground.perlin(5, 0.9).normalize(0.75, 1).getColor((0, _utils.randColor)([224, 207, 159]));

    // brick
    var cement = new _buffer2.default(tileSize * 8);
    var cementImg = cement.perlin(5, 0.5).diff([1, 0.5]).diff([-0.5, 1]).normalize(0, 1).getColor((0, _utils.randColor)([100, 100, 100]));

    var noise = new _buffer2.default(tileSize * 8);
    noise.perlin(5, 0.5).diff([1, 0.5]).normalize(0.7, 1.3);

    var brick = new _buffer2.default(tileSize * 8);
    var brickImg = brick.brick(8, 16).normalize(0.7, 1).forBuf(noise, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([200, 80, 60]));

    var brickMask = new _buffer2.default(tileSize * 8);
    this.brick = brickMask.brickMask(8, 16).gaussian(3).clamp(0.1, 0.3).normalize(0, 1).getColorLerp(brickImg, cementImg);

    // beton
    var betonNoise = new _buffer2.default(tileSize * 8);
    betonNoise.perlin(5, 0.5).forEach(function (a) {
        return a * a;
    }).diffFree().normalize(0.6, 1);

    var beton = new _buffer2.default(tileSize * 8);
    var betonImg = beton.brick(4, 4).normalize(0.7, 1).forBuf(betonNoise, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([160, 160, 160]));

    var betonMask = new _buffer2.default(tileSize * 8);
    this.beton = betonMask.brickMask(4, 4).gaussian(3).clamp(0.1, 0.3).normalize(0, 1).getColorLerp(betonImg, cementImg);

    // lava
    var lava = new _buffer2.default(tileSize * 8);
    this.lava = lava.perlin(10, 0.5).normalize(0, 30).forEach(Math.cos).normalize(0.5, 1).getColor2((0, _utils.randColor)([255, 0, 0]), (0, _utils.randColor)([255, 255, 0]));

    this.lavaMask = new Array(8);
    this.lavaLightMask = new Array(8);
    for (var i = 0; i < this.lavaMask.length; i++) {
        var lavaNoise = new _buffer2.default(tileSize * 2);
        lavaNoise.perlin(5, 0.5);

        var lavaMask = new _buffer2.default(tileSize * 2);
        this.lavaMask[i] = lavaMask.normSquare(0.4, 0.5).normalize(0, 1).forBuf(lavaNoise, function (a, b) {
            return a + 0.25 * b;
        }).clamp(0.4, 0.6).normalize(0, 1).getColor([255, 255, 255], lavaMask);

        var lavaLightMask = new _buffer2.default(tileSize * 2);
        this.lavaLightMask[i] = lavaLightMask.normSquare(0.4, 0.5).normalize(0, 1.5).forBuf(lavaNoise, function (a, b) {
            return a + 0.25 * b;
        }).clamp(0.25, 0.75).gaussian(7).normalize(0, 1).getColor([127, 127, 127], lavaLightMask);
    }

    // grass
    var grass = new _buffer2.default(tileSize * 8);
    this.grass = grass.perlin(5, 0.5).diffFree().normalize(0.7, 1.3).getColor((0, _utils.randColor)([49, 107, 54]));

    this.grassMask = new Array(8);
    for (var _i = 0; _i < this.grassMask.length; _i++) {
        var normDist = new _buffer2.default(tileSize * 2);
        normDist.normDist(1.25).normalize(0, 3).clamp(0, 1);

        var grassMask = new _buffer2.default(tileSize * 2);
        this.grassMask[_i] = grassMask.perlin(20, 0.9).normalize(0, 1).forBuf(normDist, function (a, b) {
            return a * b;
        }).clamp(0.2, 0.5).normalize(0, 1).getColor((0, _utils.randColor)([255, 255, 255]), grassMask);
    }

    // board
    var boardMask = new _buffer2.default(tileSize);
    boardMask.forEach(function () {
        return 1;
    }).bresenham(0, 0, boardMask.size - 1, 0, 0).bresenham(0, boardMask.size - 1, boardMask.size - 1, boardMask.size - 1, 0).bresenham(0, 0, 0, boardMask.size - 1, 0).bresenham(boardMask.size - 1, 0, boardMask.size - 1, boardMask.size - 1, 0).gaussian(2);

    var board = new _buffer2.default(tileSize);
    this.board = board.perlin(2, 0.5).normalize(0.7, 1).forBuf(boardMask, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([188, 198, 204]));

    // Eagle
    var eagle = new _buffer2.default(tileSize * 2);
    var center = eagle.size * 0.5 | 0;
    var step = eagle.size * 0.1 | 0;
    eagle.bresenham(center, center + step, 2 * step, 2 * step, 1).bresenham(center, center + step, eagle.size - 2 * step, 2 * step, 1).bresenham(center, step, center, eagle.size - step, 1).bresenham(center - 2 * step, center + 2 * step, 3 * step, 3 * step, 1).bresenham(center + 2 * step, center + 2 * step, eagle.size - 3 * step, 3 * step, 1).bresenham(center - 2 * step, center + 2 * step, center, center, 1).bresenham(center + 2 * step, center + 2 * step, center, center, 1).gaussian(step).normalize(0, 1).bresenham(center, eagle.size - 2 * step, center - 2 * step, eagle.size - step, 1.5).bresenham(center, eagle.size - 2 * step, center + 2 * step, eagle.size - step, 1.5).bresenham(center - step, step, center, step, 1).bresenham(center, step * 1.5 | 0, center + step * 1.5 | 0, step * 1.5 | 0, 1).bresenham(step * 2, step * 2, step, step, 1.5).bresenham(eagle.size - step * 2, step * 2, eagle.size - step, step, 1.5).bresenham(3 * step, 3 * step, step, 3 * step, 1).bresenham(eagle.size - 3 * step, 3 * step, eagle.size - step, 3 * step, 1).bresenham(4 * step, 4 * step, step, 4 * step, 1).bresenham(eagle.size - 4 * step, 4 * step, eagle.size - step, 4 * step, 1).gaussian(step).normalize(0, 1);

    var eagleMask = new _buffer2.default(eagle.size);
    eagleMask.copy(eagle).clamp(0.1, 0.2).normalize(0, 1);

    var eagleColor = new _buffer2.default(eagle.size);
    this.eagle = eagleColor.forEach(function () {
        return 1;
    }).bresenham(center, step, center, step, 0).gaussian(step).normalize(0, 1).clamp(0.2, 0.25).normalize(0, 1).forBuf(eagleMask, function (a, b) {
        return a * (5 * (Math.abs(b - 0.5) - 0.5) + 1);
    }).forBuf(eagle, function (a, b) {
        return a + b * 0.5;
    }).getColor2([0, 0, 0], [128, 128, 128], eagleMask);

    // Bridge
    this.bridge = new Array(8);

    var _loop = function _loop(k) {
        var bridgeMask = new _buffer2.default(tileSize * 2);
        bridgeMask.perlin(5, 0.5).forEach(function (a, i, j) {
            var x = (i / bridgeMask.size - 0.5) * 2;
            var y = (j / bridgeMask.size - 0.5) * 2;
            var factorX = Math.abs(x) < 0.4 ? 1 : 0;
            var factorY = (0, _utils.clamp)(2 - 2 * Math.abs(y), 0, 1);
            factorY += 0.25 * a;
            factorY = ((0, _utils.clamp)(factorY, 0.3, 0.4) - 0.3) * 10;
            return factorX * factorY;
        });

        var bridge = new _buffer2.default(tileSize * 2);
        _this.bridge[k] = bridge.perlin(5, 0.5).forEach(function (a) {
            return a * a;
        }).diffFree().normalize(0.5, 1.5).forEach(function (a, i) {
            var x = i / bridge.size * Math.PI * 8;
            return a * Math.abs(Math.cos(x));
        }).forBuf(bridgeMask, function (a, b) {
            return a * b * b;
        }).normalize(0.5, 1).getColor([182, 155, 76], bridgeMask);
    };

    for (var k = 0; k < this.bridge.length; k++) {
        _loop(k);
    }

    // Tanks
    var createTrack = function createTrack(size, isWheel) {
        var trackMask = new _buffer2.default(tileSize * 2);
        trackMask.forEach(function (a, i, j) {
            var x = (i / trackMask.size - 0.5) * 2;
            var y = (j / trackMask.size - 0.5) * 2;
            var factorX = Math.abs(x) < size ? 1 : 0;
            factorX *= Math.abs(x) < 0.5 ? 0 : 1;
            var factorY = Math.abs(y) < size ? 1 : 0;
            var wheel = j / trackMask.size * Math.PI * 3;
            wheel = Math.abs(Math.sin(wheel));
            wheel = wheel < 0.5 && isWheel ? 0 : 1;
            factorY *= wheel;
            return factorX * factorY;
        });

        var track = new _buffer2.default(tileSize * 2);
        return track.forEach(function (a, i, j) {
            var y = j / track.size * Math.PI * (isWheel ? 15 : 10);
            return Math.abs(Math.cos(y));
        }).normalize(0.5, isWheel ? 0.6 : 1).getColor([160, 160, 160], trackMask);
    };
    var smoothedSquare = function smoothedSquare(buffer, width, height) {
        buffer.forEach(function (a, i, j) {
            var x = (i / buffer.size - 0.5) * 2;
            var y = (j / buffer.size - 0.5) * 2;
            var factorX = Math.abs(x) < width ? 1 : 0;
            var factorY = Math.abs(y) < height ? 1 : 0;
            return factorX * factorY;
        }).gaussian(step);
        return buffer;
    };
    var createCorpus = function createCorpus(size, color) {
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.6;

        var corpusMask = new _buffer2.default(tileSize * 2);
        smoothedSquare(corpusMask, width, size).clamp(0.5, 0.6).normalize(0, 1);

        var corpus = new _buffer2.default(tileSize * 2);
        return corpus.brick(10, 10).diff([1, 0.5]).normalize(0, 1).forEach(function (a, i, j) {
            var y = (j / corpus.size - 0.5) * 2;
            if (Math.abs(y) < size * 0.5) return a;
            var k = (0, _utils.clamp)((size - Math.abs(y)) / (size * 0.5), 0, 1);
            return a * Math.sqrt(k);
        }).normalize(0.25, 1).getColor(color, corpusMask);
    };
    var createTurret = function createTurret(size, barrelWidth, barrelLength, color) {
        var barrelMask = new _buffer2.default(tileSize * 2);
        smoothedSquare(barrelMask, barrelWidth, barrelLength).clamp(0.5, 0.6).normalize(0, 1).forEach(function (a, i, j) {
            return j < barrelMask.size * 0.5 ? a : 0;
        });

        var barrel = new _buffer2.default(tileSize * 2);
        var barrelImg = smoothedSquare(barrel, barrelWidth, barrelLength).diff([1, 0.5]).normalize(0.25, 1).getColor([200, 200, 200], barrelMask);

        var turretMask = new _buffer2.default(tileSize * 2);
        smoothedSquare(turretMask, size, size).clamp(0.5, 0.6).normalize(0, 1);

        var turret = new _buffer2.default(tileSize * 2);
        var turretImg = smoothedSquare(turret, size, size).diff([1, 0.5]).normalize(0.25, 1).getColor(color, turretMask);

        var ctx = barrelImg.getContext("2d");
        ctx.drawImage(turretImg, 0, 0);
        return barrelImg;
    };

    /* eslint-disable key-spacing */
    var colors = (_colors = {}, _defineProperty(_colors, _tank.TANK.TANK1, [200, 150, 100]), _defineProperty(_colors, _tank.TANK.TANK2, [200, 150, 100]), _defineProperty(_colors, _tank.TANK.SIMPLE, [120, 200, 120]), _defineProperty(_colors, _tank.TANK.BMP, [200, 200, 200]), _defineProperty(_colors, _tank.TANK.CANNON, [250, 230, 134]), _defineProperty(_colors, _tank.TANK.STRONG, [100, 200, 180]), _defineProperty(_colors, _tank.TANK.PANZER, [211, 229, 224]), _colors);

    this.tankBodies = (_tankBodies = {}, _defineProperty(_tankBodies, _tank.TANK.TANK1, createCorpus(0.7, colors[_tank.TANK.TANK1])), _defineProperty(_tankBodies, _tank.TANK.TANK2, createCorpus(0.7, colors[_tank.TANK.TANK2])), _defineProperty(_tankBodies, _tank.TANK.SIMPLE, createCorpus(0.5, colors[_tank.TANK.SIMPLE])), _defineProperty(_tankBodies, _tank.TANK.BMP, createCorpus(0.7, colors[_tank.TANK.BMP], 0.5)), _defineProperty(_tankBodies, _tank.TANK.CANNON, createCorpus(0.5, colors[_tank.TANK.CANNON])), _defineProperty(_tankBodies, _tank.TANK.STRONG, createCorpus(0.75, colors[_tank.TANK.STRONG])), _defineProperty(_tankBodies, _tank.TANK.PANZER, createCorpus(1, colors[_tank.TANK.PANZER])), _tankBodies);

    this.tankTurret = (_tankTurret = {}, _defineProperty(_tankTurret, _tank.TANK.TANK1, createTurret(0.35, 0.1, 0.7, colors[_tank.TANK.TANK1])), _defineProperty(_tankTurret, _tank.TANK.TANK2, createTurret(0.35, 0.1, 0.7, colors[_tank.TANK.TANK2])), _defineProperty(_tankTurret, _tank.TANK.SIMPLE, createTurret(0.35, 0.1, 0.7, colors[_tank.TANK.SIMPLE])), _defineProperty(_tankTurret, _tank.TANK.BMP, createTurret(0.2, 0.1, 0.6, colors[_tank.TANK.BMP])), _defineProperty(_tankTurret, _tank.TANK.CANNON, createTurret(0.35, 0.1, 0.95, colors[_tank.TANK.CANNON])), _defineProperty(_tankTurret, _tank.TANK.STRONG, createTurret(0.35, 0.1, 0.7, colors[_tank.TANK.STRONG])), _defineProperty(_tankTurret, _tank.TANK.PANZER, createTurret(0.5, 0.2, 0.95, colors[_tank.TANK.PANZER])), _tankTurret);

    var trackSimple = createTrack(0.8, false);
    var trackBMP = createTrack(0.7, true);
    var trackPanzer = createTrack(1, false);

    this.tankTrack = (_tankTrack = {}, _defineProperty(_tankTrack, _tank.TANK.TANK1, trackSimple), _defineProperty(_tankTrack, _tank.TANK.TANK2, trackSimple), _defineProperty(_tankTrack, _tank.TANK.SIMPLE, trackSimple), _defineProperty(_tankTrack, _tank.TANK.BMP, trackBMP), _defineProperty(_tankTrack, _tank.TANK.CANNON, trackSimple), _defineProperty(_tankTrack, _tank.TANK.STRONG, trackSimple), _defineProperty(_tankTrack, _tank.TANK.PANZER, trackPanzer), _tankTrack);
    /* eslint-enable key-spacing */
};

exports.default = GenTextures;
},{"../tank":7,"../utils":8,"./buffer":3}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("./utils");

var _genTextures = require("./gener/genTextures");

var _genTextures2 = _interopRequireDefault(_genTextures);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EMPTY = 0;
var HALF = 1;
var BRICK = 2;
var BETON = 4;
var WATER = 8;
var GRASS = 16;
var BRIDGEH = 32;
var BRIDGEV = 64;
var BRIDGE = BRIDGEH | BRIDGEV;
var MOVE_MASK = HALF | BRICK | BETON | WATER;
var BULLET_MASK = HALF | BRICK | BETON;

var Layer = function Layer(width, height) {
    _classCallCheck(this, Layer);

    this.canvas = document.createElement("canvas");
    this.canvas.width = width;
    this.canvas.height = height;
    this.context = this.canvas.getContext("2d");
};

var Level = function () {
    function Level(levelName, canvas) {
        var _this = this;

        _classCallCheck(this, Level);

        var _getMapSize = (0, _utils.getMapSize)(),
            mapWidth = _getMapSize.mapWidth,
            mapHeight = _getMapSize.mapHeight;

        var tileSize = (0, _utils.getTileSize)(canvas.width, canvas.height);
        console.log("tileSize = " + tileSize);

        this.tileSize = tileSize;
        this.textures = new _genTextures2.default(tileSize);
        this.layerGround = new Layer(mapWidth * tileSize, mapHeight * tileSize);
        this.layerBrick = new Layer(mapWidth * tileSize, mapHeight * tileSize);
        this.layerGrass = new Layer(mapWidth * tileSize, mapHeight * tileSize);
        var layerLava = new Layer(mapWidth * tileSize, mapHeight * tileSize);

        var renderBoard = function renderBoard() {
            // render horizontal board
            for (var i = 0; i < mapWidth; i++) {
                _this.layerGround.context.drawImage(_this.textures.board, i * tileSize, 0);
                _this.layerGround.context.drawImage(_this.textures.board, i * tileSize, (mapHeight - 1) * tileSize);
            }
            // render vertical board
            for (var _i = 1; _i < mapHeight - 1; _i++) {
                _this.layerGround.context.drawImage(_this.textures.board, 0, _i * tileSize);
                _this.layerGround.context.drawImage(_this.textures.board, (mapWidth - 1) * tileSize, _i * tileSize);
            }
        };
        var renderTexture = function renderTexture(destLayer, texture) {
            for (var y = 0; y < destLayer.canvas.height; y += texture.height) {
                for (var x = 0; x < destLayer.canvas.width; x += texture.width) {
                    destLayer.context.drawImage(texture, x, y);
                }
            }
        };
        var calcTilePos = function calcTilePos(index, minusHalf) {
            var x = 1 + index % (mapWidth - 2) | 0;
            var y = 1 + index / (mapWidth - 2) | 0;
            var posX = x * tileSize;
            var posY = y * tileSize;
            if (minusHalf) {
                posX -= tileSize / 2 | 0;
                posY -= tileSize / 2 | 0;
            }
            return { posX: posX, posY: posY };
        };
        var renderLava = function renderLava() {
            var oldGround = _this.layerGround.context.globalCompositeOperation;
            _this.layerGround.context.globalCompositeOperation = "multiply";

            _this.map.forEach(function (tile, index) {
                if (tile & (WATER | BRIDGE)) {
                    var _calcTilePos = calcTilePos(index, true),
                        posX = _calcTilePos.posX,
                        posY = _calcTilePos.posY;

                    var ind = Math.random() * _this.textures.lavaMask.length | 0;
                    layerLava.context.drawImage(_this.textures.lavaMask[ind], posX, posY);
                    _this.layerGround.context.drawImage(_this.textures.lavaLightMask[ind], posX, posY);
                }
            });

            var oldLava = layerLava.context.globalCompositeOperation;
            layerLava.context.globalCompositeOperation = "source-atop";

            renderTexture(layerLava, _this.textures.lava);

            _this.layerGround.context.globalCompositeOperation = oldGround;
            layerLava.context.globalCompositeOperation = oldLava;
        };
        var renderBridge = function renderBridge() {
            _this.map.forEach(function (tile, index) {
                if (tile & BRIDGE) {
                    var _calcTilePos2 = calcTilePos(index, true),
                        posX = _calcTilePos2.posX,
                        posY = _calcTilePos2.posY;

                    var ind = Math.random() * _this.textures.bridge.length | 0;
                    if (tile === BRIDGEV) {
                        layerLava.context.drawImage(_this.textures.bridge[ind], posX, posY);
                    } else {
                        layerLava.context.save();

                        layerLava.context.translate(posX, posY);
                        layerLava.context.rotate(Math.PI * 0.5);
                        layerLava.context.scale(1, -1);
                        layerLava.context.drawImage(_this.textures.bridge[ind], 0, 0);

                        layerLava.context.restore();
                    }
                }
            });
        };
        var renderBrick = function renderBrick() {
            _this.map.forEach(function (tile, index) {
                if (tile & (BRICK | BETON)) {
                    var _calcTilePos3 = calcTilePos(index, false),
                        posX = _calcTilePos3.posX,
                        posY = _calcTilePos3.posY;

                    var img = tile & BRICK ? _this.textures.brick : _this.textures.beton;
                    var srcX = posX % img.width | 0;
                    var srcY = posY % img.height | 0;
                    _this.layerBrick.context.drawImage(img, srcX, srcY, tileSize, tileSize, posX, posY, tileSize, tileSize);
                }
            });
        };
        var renderGrass = function renderGrass() {
            _this.map.forEach(function (tile, index) {
                if (tile === GRASS) {
                    var _calcTilePos4 = calcTilePos(index, true),
                        posX = _calcTilePos4.posX,
                        posY = _calcTilePos4.posY;

                    var ind = Math.random() * _this.textures.lavaMask.length | 0;
                    _this.layerGrass.context.drawImage(_this.textures.grassMask[ind], posX, posY);
                }
            });

            var oldGrass = _this.layerGrass.context.globalCompositeOperation;
            _this.layerGrass.context.globalCompositeOperation = "source-atop";

            renderTexture(_this.layerGrass, _this.textures.grass);

            _this.layerGrass.context.globalCompositeOperation = oldGrass;
        };

        var loadLevel = function loadLevel(callback) {
            console.log("Loading " + levelName + ".tmx level");
            var reader = new XMLHttpRequest();
            reader.open("get", levelName + ".tmx", true);
            reader.onload = function () {
                var parser = new DOMParser();
                var xml = parser.parseFromString(reader.responseText, "text/xml");

                console.assert(xml.children.length === 1, "Count children must bu 1");

                var attrs = xml.children[0].attributes;
                console.assert(attrs.width.textContent === "" + (mapWidth - 2));
                console.assert(attrs.height.textContent === "" + (mapHeight - 2));
                console.assert(xml.children[0].children.length === 2, "Should be tileset and layer");
                console.assert(xml.children[0].children[1].children.length === 1, "Should be data");

                var data = xml.children[0].children[1].children[0].innerHTML.split(/\s|,/).filter(function (val) {
                    return val !== "";
                }).map(function (val) {
                    return parseInt(val, 10);
                });
                console.assert(data.length === (mapWidth - 2) * (mapHeight - 2), "Wrong count tiles");

                _this.map = data.map(function (val) {
                    switch (val) {
                        case 0:
                            return EMPTY;
                        case 1:
                            return BRICK;
                        case 2:
                            return BETON;
                        case 3:
                            return WATER;
                        case 4:
                            return GRASS;
                        case 5:
                            return BRIDGEH;
                        case 6:
                            return BRIDGEV;
                        default:
                            return console.assert(false, "Unknown tile type " + val);
                    }
                });

                callback();
            };
            reader.onerror = function () {
                return console.assert(false, "Couldn't load " + levelName + ".tmx");
            };
            reader.send();
        };

        loadLevel(function () {
            var renderTime = Date.now();

            renderTexture(_this.layerGround, _this.textures.ground);
            renderLava();
            renderBridge();
            renderBoard();
            renderBrick();
            renderGrass();

            _this.layerGround.context.drawImage(layerLava.canvas, 0, 0);

            _this.context = canvas.getContext("2d");
            _this.context.drawImage(_this.layerGround.canvas, 0, 0);
            _this.context.drawImage(_this.layerBrick.canvas, 0, 0);
            _this.context.drawImage(_this.layerGrass.canvas, 0, 0);

            console.log("Render time = " + (Date.now() - renderTime));
        });
    }

    _createClass(Level, [{
        key: "ready",
        value: function ready() {
            return !!this.context;
        }
    }, {
        key: "clearEntity",
        value: function clearEntity(entity) {
            var x = entity.cx + 1 - entity.size * 0.5; // for board
            var y = entity.cy + 1 - entity.size * 0.5; // for board
            this.context.drawImage(this.layerGround.canvas, x * this.tileSize, y * this.tileSize, // src pos
            entity.size * this.tileSize, entity.size * this.tileSize, // src size
            x * this.tileSize, y * this.tileSize, // dest pos
            entity.size * this.tileSize, entity.size * this.tileSize); // dest size
        }
    }, {
        key: "drawEntity",
        value: function drawEntity(entity, texture) {
            var x = entity.cx + 1 - entity.size * 0.5; // for board
            var y = entity.cy + 1 - entity.size * 0.5; // for board
            this.context.drawImage(texture, 0, 0, // src pos
            entity.size * this.tileSize, entity.size * this.tileSize, // src size
            x * this.tileSize, y * this.tileSize, // dest pos
            entity.size * this.tileSize, entity.size * this.tileSize); // dest size
        }
    }]);

    return Level;
}();

exports.default = Level;
},{"./gener/genTextures":4,"./utils":8}],6:[function(require,module,exports){
"use strict";

var _utils = require("./utils");

var _game = require("./game");

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Size of map 36x20
function calcSizeForCanvas(width, height) {
    var _getMapSize = (0, _utils.getMapSize)(),
        mapWidth = _getMapSize.mapWidth,
        mapHeight = _getMapSize.mapHeight;

    var aspect = width / height;
    var mapAspect = mapWidth / (mapHeight + 1); // +1 for UI

    if (mapAspect > aspect) {
        return { width: width, height: width / mapAspect };
    }
    return { width: height * mapAspect, height: height };
}

function getRequestAnimationFrame() {
    if (window.requestAnimationFrame) return window.requestAnimationFrame;

    var vendors = ["webkit", "moz", "ms", "o"];
    for (var i = 0; i < vendors.length; i++) {
        if (window[vendors[i] + "RequestAnimationFrame"]) {
            return window[vendors[i] + "RequestAnimationFrame"];
        }
    }

    // Manual fallbacks
    var lastTime = 0;
    return function (callback) {
        var currTime = Date.now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            return callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}

function main() {
    console.assert = function (condition) {
        var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";

        if (!condition) {
            console.log(message);
            if (typeof Error !== "undefined") {
                throw new Error(message);
            }
            throw message; // Fallback
        }
    };

    var canvas = document.getElementById("canvas");

    var _calcSizeForCanvas = calcSizeForCanvas(window.innerWidth - 40, window.innerHeight - 40),
        width = _calcSizeForCanvas.width,
        height = _calcSizeForCanvas.height;

    canvas.width = width;
    canvas.height = height;

    var game = new _game2.default(-2, canvas, "test");

    // calc FPS
    var lastTime = 0;
    var frameCount = 0;
    var calcFPS = function calcFPS() {
        var now = Date.now();
        frameCount++;
        if (now > lastTime) {
            var tileSize = (0, _utils.getTileSize)(canvas.width, canvas.height);
            var context = canvas.getContext("2d");
            context.fillStyle = "black";
            context.fillRect(0, canvas.height - tileSize, 100, tileSize);
            context.font = (tileSize * 0.5 | 0) + "px Verdana, Geneva, Arial, Helvetica, sans-serif";
            context.fillStyle = "white";
            context.fillText("FPS = " + frameCount, 0, canvas.height - 10);

            lastTime = now + 1000;
            frameCount = 0;
        }
    };

    var animationFrame = getRequestAnimationFrame();
    var update = function update() {
        game.update();
        calcFPS();

        animationFrame(update);
    };
    update();

    // events
    document.onkeydown = function (event) {
        game.onkeydown(event.keyCode);
        event.preventDefault();
    };
    document.onkeyup = function (event) {
        game.onkeyup(event.keyCode);
        event.preventDefault();
    };
}
window.addEventListener("load", main);
},{"./game":2,"./utils":8}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tank = exports.TANK = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _entity = require("./entity");

var _entity2 = _interopRequireDefault(_entity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TANK = exports.TANK = {
    TANK1: 0,
    TANK2: 1,
    SIMPLE: 2,
    BMP: 3,
    CANNON: 4,
    STRONG: 5,
    PANZER: 6,
    RANDOM: 7
};

var Tank = exports.Tank = function (_Entity) {
    _inherits(Tank, _Entity);

    function Tank(cx, cy, type) {
        _classCallCheck(this, Tank);

        var _this = _possibleConstructorReturn(this, (Tank.__proto__ || Object.getPrototypeOf(Tank)).call(this, cx, cy));

        _this.type = type;
        return _this;
    }

    _createClass(Tank, [{
        key: "clear",
        value: function clear(level) {
            level.clearEntity(this);
        }
    }, {
        key: "draw",
        value: function draw(level) {
            level.drawEntity(this, level.textures.tankTrack[this.type]);
            level.drawEntity(this, level.textures.tankBodies[this.type]);
            level.drawEntity(this, level.textures.tankTurret[this.type]);
        }
    }, {
        key: "update",
        value: function update(delta) {
            this.move(delta);
        }
    }]);

    return Tank;
}(_entity2.default);
},{"./entity":1}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rand = rand;
exports.clamp = clamp;
exports.randColor = randColor;
exports.getMapSize = getMapSize;
exports.getTileSize = getTileSize;
function rand(m, radius) {
    return 2 * radius * Math.random() - radius + m;
}

function clamp(a, min, max) {
    return Math.max(min, Math.min(max, a));
}

function randColor(color) {
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    var ret = new Array(3);
    for (var i = 0; i < 3; i++) {
        ret[i] = clamp(rand(color[i], radius), 0, 255);
    }return ret;
}

function getMapSize() {
    var mapWidth = 36;
    var mapHeight = 20;
    mapWidth += 1 + 1; // for board;
    mapHeight += 1 + 1; // for board;
    return { mapWidth: mapWidth, mapHeight: mapHeight };
}

function getTileSize(width, height) {
    var _getMapSize = getMapSize(),
        mapWidth = _getMapSize.mapWidth,
        mapHeight = _getMapSize.mapHeight;

    var tileWidth = width / mapWidth | 0;
    var tileHeight = height / mapHeight | 0;
    return Math.min(tileWidth, tileHeight);
}
},{}]},{},[6]);
