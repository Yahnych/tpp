(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleBuffer = function () {
    function SimpleBuffer(size) {
        _classCallCheck(this, SimpleBuffer);

        this.data = new Float32Array(size * size);
        this.size = size;
        this.data.fill(0.0);
    }

    _createClass(SimpleBuffer, [{
        key: "getData",
        value: function getData(x, y) {
            return y !== undefined ? this.data[y * this.size + x | 0] : this.data[x];
        }
    }, {
        key: "setData",
        value: function setData(x, y, val) {
            if (val !== undefined) this.data[y * this.size + x | 0] = val;else this.data[x] = y; // setData(index, val);
        }
    }, {
        key: "getSize",
        value: function getSize() {
            return this.size;
        }
    }, {
        key: "getColor",
        value: function getColor(context) {
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = this.data[i] * 255 | 0;
                imageData.data[4 * i + 1] = this.data[i] * 255 | 0;
                imageData.data[4 * i + 2] = this.data[i] * 255 | 0;
                imageData.data[4 * i + 3] = 255;
            }
            return imageData;
        }
    }, {
        key: "perlin",
        value: function perlin(startFreq, koef) {
            var _this = this;

            var time = Date.now();
            var extrem = function extrem(freq, ampl) {
                var dispersion = function dispersion(rad) {
                    return 2 * rad * Math.random() - rad;
                };

                var ret = new Array(freq * freq);
                for (var i = 0; i < freq * freq; i++) {
                    ret[i] = dispersion(ampl);
                }
                return ret;
            };
            var cosLerp = function cosLerp(a, b, t) {
                var ft = t * Math.PI;
                var f = (1 - Math.cos(ft)) * 0.5;
                return a * (1 - f) + b * f;
            };

            var ampl = 1;
            var freq = startFreq;

            var _loop = function _loop() {
                var buf = extrem(freq, ampl);
                var bufData = function bufData(x, y) {
                    return buf[y * freq + x | 0];
                };

                for (var j = 0; j < _this.size; j++) {
                    for (var i = 0; i < _this.size; i++) {
                        var x = i * freq / _this.size | 0;
                        var y = j * freq / _this.size | 0;
                        var tx = i * freq / _this.size - x;
                        var ty = j * freq / _this.size - y;
                        var x1 = bufData(x, y);
                        var oldX = x;
                        x++;
                        if (x > freq - 1) x = 0;
                        var x2 = bufData(x, y);
                        var xx = cosLerp(x1, x2, tx);

                        y++;
                        if (y > freq - 1) y = 0;
                        var y1 = bufData(oldX, y);
                        var y2 = bufData(x, y);
                        var yy = cosLerp(y1, y2, tx);
                        var h = cosLerp(xx, yy, ty);

                        _this.data[_this.size * j + i | 0] += h;
                    }
                }
                freq *= 2;
                ampl *= koef;
            };

            do {
                _loop();
            } while (freq < this.size);

            console.log("Perlin noise = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normalize",
        value: function normalize(a, b) {
            var time = Date.now();
            var min = this.data[0];
            var max = this.data[0];
            for (var i = 1; i < this.size * this.size; i++) {
                max = Math.max(max, this.data[i]);
                min = Math.min(min, this.data[i]);
            }
            var k = (b - a) / (max - min);
            for (var _i = 0; _i < this.size * this.size; _i++) {
                this.data[_i] = (this.data[_i] - min) * k + a;
            }
            console.log("Normalize = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forEach",
        value: function forEach(fun) {
            var time = Date.now();
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    this.data[j * this.size + i | 0] = fun(this.getData(i, j), i, j);
                }
            }
            console.log("For each = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forBuf",
        value: function forBuf(buf, fun) {
            var time = Date.now();
            console.assert(this.size === buf.getSize(), "Sizes of buffers must be equal");
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    this.data[j * this.size + i | 0] = fun(this.getData(i, j), buf.getData(i, j), i, j);
                }
            }
            console.log("For buffer = ", Date.now() - time);
            return this;
        }
    }, {
        key: "clamp",
        value: function clamp(a, b) {
            var time = Date.now();
            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = Math.max(a, Math.min(b, this.data[i]));
            }
            console.log("Clamp = ", Date.now() - time);
            return this;
        }
        /* this.gaussian_fast = function(radius, src_buf, dir, mask)
        {
            var time = Date.now();
            Console.assert(size === src_buf.getSize(), "Sizes of buffers must be equal");
            Console.assert(self !== src_buf, "Source buffer must does not be same with this");
            if (mask)
            {
                Console.assert(size === mask.getSize(), "Sizes of buffers must be equal");
                Console.assert(self !== mask, "Source buffer must does not be same with this");
            }
             function norm(x)
            {
                const a = 1 / (Math.sqrt(2 * Math.PI));
                const b = -x * x / 2;
                return a * Math.exp(b);
            }
             for (var j = 0; j < size; j++)
            {
                for (var i = 0; i < size; i++)
                {
                    if (mask && mask.getData(i, j) < 0.5)
                        continue;
                     var kol = 0.0;
                    var sum = 0.0;
                    for (var p = -radius; p <= radius; p++)
                    {
                        var x = i + dir[0] * p;
                        var y = j + dir[1] * p;
                        if (y < 0) continue;
                        if (y >= size) break;
                        if (x < 0) continue;
                        if (x >= size) break;
                         var sx = (x - i) / radius;
                        var sy = (y - j) / radius;
                        var r = Math.sqrt(sx * sx + sy * sy);
                        var koef = norm(r * 3);
                        kol += koef;
                        sum += koef * src_buf.getData(x, y);
                    }
                    var ind = i + j * size | 0;
                    data[ind] = sum / kol;
                }
            }
            Console.info("Gaussian fast = ", Date.now() - time);
        }
        this.getGaussian = function(radius, mask)
        {
            var blur_x = new Buffer(size);
            var blur = new Buffer(size);
            blur_x.gaussian_fast(radius, self, [1, 0], mask);
            blur.gaussian_fast(radius, blur_x, [0, 1], mask);
            return blur;
        }
        this.copy = function(src_image)
        {
            var time = Date.now();
            Console.assert(size === src_image.getSize(), "Sizes of buffers must be equal");
            Console.assert(self !== src_image, "Source buffer must does not be same with this");
             for (var i = 0;  i < size * size; i++)
                data[i] = src_image.getData(i);
             Console.info("Copy = ", Date.now() - time);
        }
        this.bresenham = function(x0, y0, x1, y1, val)
        {
            var dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
            var dy = Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
            var err = (dx > dy ? dx : -dy) / 2;
             while (true)
            {
                if (x0 >= 0 && x0 < size &&
                    y0 >= 0 && y0 < size)
                {
                    data[x0 + y0 * size] = val;
                }
                if (x0 === x1 && y0 === y1) break;
                var e2 = err;
                if (e2 > -dx) { err -= dy; x0 += sx; }
                if (e2 < dy) { err += dx; y0 += sy; }
            }
        } */

    }]);

    return SimpleBuffer;
}();

exports.default = SimpleBuffer;
},{}],2:[function(require,module,exports){
"use strict";

var _buffer = require("./gener/buffer");

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function calcSizeMap() {
    var mapWidth = 36;
    var mapHeight = 20;
    mapWidth += 1 + 1; // for board;
    mapHeight += 1 + 1 + 1; // for board and UI
    return { mapWidth: mapWidth, mapHeight: mapHeight };
}

// Size of map 36x20
function calcSizeForCanvas(width, height) {
    var _calcSizeMap = calcSizeMap(),
        mapWidth = _calcSizeMap.mapWidth,
        mapHeight = _calcSizeMap.mapHeight;

    var aspect = width / height;
    var mapAspect = mapWidth / mapHeight;

    if (mapAspect > aspect) {
        return { width: width, height: width / mapAspect };
    }
    return { width: height * mapAspect, height: height };
}

function main() {
    console.assert = function (condition) {
        var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";

        if (!condition) {
            console.log(message);
            if (typeof Error !== "undefined") {
                throw new Error(message);
            }
            throw message; // Fallback
        }
    };

    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");

    var _calcSizeForCanvas = calcSizeForCanvas(window.innerWidth - 40, window.innerHeight - 40),
        width = _calcSizeForCanvas.width,
        height = _calcSizeForCanvas.height;

    canvas.width = width;
    canvas.height = height;

    var buffer = new _buffer2.default(512);
    var image = buffer.perlin(5, 0.5).normalize(0, 1).clamp(0.5, 1).getColor(context);
    context.putImageData(image, 100, 100);
}
window.addEventListener("load", main);
},{"./gener/buffer":1}]},{},[2]);
