(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("../utils");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lerp(a, b, t) {
    return a * (1 - t) + b * t;
}

function norm(x) {
    var a = 1 / Math.sqrt(2 * Math.PI);
    var b = -x * x / 2;
    return a * Math.exp(b);
}

var SimpleBuffer = function () {
    function SimpleBuffer(size) {
        _classCallCheck(this, SimpleBuffer);

        this.data = new Float32Array(size * size);
        this.size = size;
        this.data.fill(0.0);
    }

    _createClass(SimpleBuffer, [{
        key: "getData",
        value: function getData(x, y) {
            if (x < 0 || x > this.size - 1) return 0.0;
            if (y < 0 || y > this.size - 1) return 0.0;
            return this.data[y * this.size + x | 0];
        }
    }, {
        key: "setData",
        value: function setData(x, y, val) {
            if (x < 0 || x > this.size - 1) return;
            if (y < 0 || y > this.size - 1) return;
            this.data[y * this.size + x | 0] = val;
        }
    }, {
        key: "getColor",
        value: function getColor() {
            var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [255, 255, 255];

            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = col[0] * this.data[i] | 0;
                imageData.data[4 * i + 1] = col[1] * this.data[i] | 0;
                imageData.data[4 * i + 2] = col[2] * this.data[i] | 0;
                imageData.data[4 * i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColor2",
        value: function getColor2() {
            var col0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
            var col1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 255, 255];
            var mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            console.assert(!mask || mask.size === this.size, "Require same size");
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = (0, _utils.clamp)(lerp(col0[0], col1[0], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 1] = (0, _utils.clamp)(lerp(col0[1], col1[1], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 2] = (0, _utils.clamp)(lerp(col0[2], col1[2], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 3] = mask ? mask.data[i] * 255 | 0 : 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColorAlpha",
        value: function getColorAlpha(mask) {
            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 255, 255];

            console.assert(mask.size === this.size, "Require same size");
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = col[0] * this.data[i] | 0;
                imageData.data[4 * i + 1] = col[1] * this.data[i] | 0;
                imageData.data[4 * i + 2] = col[2] * this.data[i] | 0;
                imageData.data[4 * i + 3] = mask.data[i] * 255 | 0;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColorLerp",
        value: function getColorLerp(img0, img1) {
            console.assert(img0.width === img1.width, "Require same image");
            console.assert(img0.height === img1.height, "Require same image");
            console.assert(img0.width === this.size, "Require same image");
            console.assert(img0.height === this.size, "Require same image");

            var data0 = img0.getContext("2d").getImageData(0, 0, this.size, this.size).data;
            var data1 = img1.getContext("2d").getImageData(0, 0, this.size, this.size).data;
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = lerp(data0[4 * i + 0], data1[4 * i + 0], this.data[i]) | 0;
                imageData.data[4 * i + 1] = lerp(data0[4 * i + 1], data1[4 * i + 1], this.data[i]) | 0;
                imageData.data[4 * i + 2] = lerp(data0[4 * i + 2], data1[4 * i + 2], this.data[i]) | 0;
                imageData.data[4 * i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "perlin",
        value: function perlin(startFreq, koef) {
            var _this = this;

            var time = Date.now();
            var extrem = function extrem(freq, ampl) {
                var dispersion = function dispersion(rad) {
                    return (0, _utils.rand)(0, rad);
                };

                var ret = new Array(freq * freq);
                for (var i = 0; i < freq * freq; i++) {
                    ret[i] = dispersion(ampl);
                }
                return ret;
            };
            var cosLerp = function cosLerp(a, b, t) {
                var ft = t * Math.PI;
                var f = (1 - Math.cos(ft)) * 0.5;
                return a * (1 - f) + b * f;
            };

            var ampl = 1;
            var freq = startFreq;

            var _loop = function _loop() {
                var buf = extrem(freq, ampl);
                var bufData = function bufData(x, y) {
                    return buf[y * freq + x | 0];
                };

                for (var j = 0; j < _this.size; j++) {
                    for (var i = 0; i < _this.size; i++) {
                        var x = i * freq / _this.size | 0;
                        var y = j * freq / _this.size | 0;
                        var tx = i * freq / _this.size - x;
                        var ty = j * freq / _this.size - y;
                        var x1 = bufData(x, y);
                        var oldX = x;
                        x++;
                        if (x > freq - 1) x = 0;
                        var x2 = bufData(x, y);
                        var xx = cosLerp(x1, x2, tx);

                        y++;
                        if (y > freq - 1) y = 0;
                        var y1 = bufData(oldX, y);
                        var y2 = bufData(x, y);
                        var yy = cosLerp(y1, y2, tx);
                        var h = cosLerp(xx, yy, ty);

                        _this.data[_this.size * j + i | 0] += h;
                    }
                }
                freq *= 2;
                ampl *= koef;
            };

            do {
                _loop();
            } while (freq < this.size);

            console.log("Perlin noise = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normalize",
        value: function normalize(a, b) {
            var time = Date.now();
            var min = this.data[0];
            var max = this.data[0];
            for (var i = 1; i < this.size * this.size; i++) {
                max = Math.max(max, this.data[i]);
                min = Math.min(min, this.data[i]);
            }
            var k = (b - a) / (max - min);
            for (var _i = 0; _i < this.size * this.size; _i++) {
                this.data[_i] = (this.data[_i] - min) * k + a;
            }
            console.log("Normalize = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forEach",
        value: function forEach(fun) {
            var time = Date.now();
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], i, j);
                }
            }
            console.log("For each = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forBuf",
        value: function forBuf(buf, fun) {
            var time = Date.now();
            console.assert(this.size === buf.size, "Sizes of buffers must be equal");
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], buf.data[ind], i, j);
                }
            }
            console.log("For buffer = ", Date.now() - time);
            return this;
        }
    }, {
        key: "clamp",
        value: function clamp(a, b) {
            var time = Date.now();
            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = (0, _utils.clamp)(this.data[i], a, b);
            }
            console.log("Clamp = ", Date.now() - time);
            return this;
        }
    }, {
        key: "gaussianFast",
        value: function gaussianFast(srcBuf, radius, dir) {
            var time = Date.now();
            console.assert(this.size === srcBuf.size, "Sizes of buffers must be equal");
            console.assert(this !== srcBuf, "Source buffer must does not be same with this");

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var kol = 0.0;
                    var sum = 0.0;
                    for (var p = -radius; p <= radius; p++) {
                        var x = i + dir[0] * p;
                        var y = j + dir[1] * p;

                        var sx = (x - i) / radius;
                        var sy = (y - j) / radius;
                        var r = Math.sqrt(sx * sx + sy * sy);
                        var koef = norm(r * 3);
                        kol += koef;

                        if (x < 0) x += this.size;
                        if (y < 0) y += this.size;
                        if (x > this.size - 1) x -= this.size;
                        if (y > this.size - 1) y -= this.size;

                        sum += koef * srcBuf.data[y * this.size + x | 0];
                    }
                    var ind = i + j * this.size | 0;
                    this.data[ind] = sum / kol;
                }
            }
            console.log("Gaussian fast = ", Date.now() - time);
        }
    }, {
        key: "gaussian",
        value: function gaussian(radius) {
            var blur = new SimpleBuffer(this.size);
            blur.gaussianFast(this, radius, [1, 0]);
            this.gaussianFast(blur, radius, [0, 1]);
            return this;
        }
    }, {
        key: "copy",
        value: function copy(src) {
            var time = Date.now();
            console.assert(this.size === src.size, "Sizes of buffers must be equal");
            console.assert(this !== src, "Source buffer must does not be same with this");

            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = src.data[i];
            }

            console.log("Copy = ", Date.now() - time);
            return this;
        }
    }, {
        key: "bresenham",
        value: function bresenham(x0, y0, x1, y1, val) {
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var sx = x0 < x1 ? 1 : -1;
            var sy = y0 < y1 ? 1 : -1;
            var err = (dx > dy ? dx : -dy) / 2;
            var x = x0;
            var y = y0;

            for (;;) {
                this.setData(x, y, val);
                if (x === x1 && y === y1) break;
                var e2 = err;
                if (e2 > -dx) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dy) {
                    err += dx;
                    y += sy;
                }
            }
            return this;
        }
    }, {
        key: "differential",
        value: function differential(fun) {
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var nx = i + 1;
                    var ny = j + 1;
                    if (nx > this.size - 1) nx = 0;
                    if (ny > this.size - 1) ny = 0;
                    var ind00 = j * this.size + i;
                    var ind01 = ny * this.size + i;
                    var ind10 = j * this.size + nx;
                    var col00 = this.data[ind00];
                    var col01 = this.data[ind01];
                    var col10 = this.data[ind10];
                    var dx = (col10 - col00) * 0.5;
                    var dy = (col01 - col00) * 0.5;
                    fun(ind00, dx, dy);
                }
            }
        }
    }, {
        key: "diff",
        value: function diff(dir) {
            var _this2 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this2.data[ind] = dx * dir[0] + dy * dir[1];
            });

            console.log("Differential", Date.now() - time);
            return this;
        }
    }, {
        key: "diffFree",
        value: function diffFree() {
            var _this3 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this3.data[ind] = Math.sqrt(dx * dx + dy * dy);
            });

            console.log("Differential free", Date.now() - time);
            return this;
        }
    }, {
        key: "brick",
        value: function brick(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                var startY = brickY * brickHeight | 0;
                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var color = Math.random();
                    var X = startX + brickX * brickWidth | 0;
                    for (var j = startY; j < startY + brickHeight; j++) {
                        if (j > this.size - 1) break;
                        for (var i = X; i < X + brickWidth; i++) {
                            var x = i < 0 ? this.size + i : i;
                            this.data[j * this.size + x] = color;
                        }
                    }
                }
            }

            console.log("Brick generate", Date.now() - time);
            return this;
        }
    }, {
        key: "brickMask",
        value: function brickMask(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var y = brickY * brickHeight | 0;
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                this.bresenham(0, y, this.size, y, 1);

                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var x = startX + brickX * brickWidth | 0;
                    if (x < 0) x += this.size;
                    this.bresenham(x, y, x, y + brickHeight | 0, 1);
                }
            }

            console.log("Brick mask generate", Date.now() - time);
            return this;
        }
    }, {
        key: "normDist",
        value: function normDist(rad) {
            var time = Date.now();

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var x = (i - this.size * 0.5) / (rad * this.size * 0.5);
                    var y = (j - this.size * 0.5) / (rad * this.size * 0.5);
                    var r = Math.sqrt(x * x + y * y);
                    var koef = norm(r * 3);
                    this.data[j * this.size + i] = koef;
                }
            }

            console.log("Normal distribution = ", Date.now() - time);
            return this;
        }
    }]);

    return SimpleBuffer;
}();

exports.default = SimpleBuffer;
},{"../utils":5}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _buffer = require("./buffer");

var _buffer2 = _interopRequireDefault(_buffer);

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GenTextures = function GenTextures(tileSize) {
    _classCallCheck(this, GenTextures);

    var noise = new _buffer2.default(tileSize * 8);
    noise.perlin(5, 0.5).normalize(0, 1);

    // ground
    var ground = new _buffer2.default(tileSize * 8);
    this.ground = ground.perlin(5, 0.9).normalize(0.75, 1).getColor((0, _utils.randColor)([224, 207, 159]));

    // brick
    var cement = new _buffer2.default(tileSize * 8);
    var cementImg = cement.perlin(5, 0.5).diff([1, 0.5]).diff([-0.5, 1]).normalize(0, 1).getColor((0, _utils.randColor)([100, 100, 100]));

    var brick = new _buffer2.default(tileSize * 8);
    var brickImg = brick.brick(4, 8).forBuf(noise, function (a, b) {
        return a * b;
    }).normalize(0.7, 1).getColor((0, _utils.randColor)([160, 54, 35]));

    var brickMask = new _buffer2.default(tileSize * 8);
    this.brick = brickMask.brickMask(4, 8).gaussian(3).clamp(0.1, 0.3).normalize(0, 1).getColorLerp(brickImg, cementImg);

    // beton
    var betonNoise = new _buffer2.default(tileSize * 8);
    betonNoise.perlin(5, 0.5).forEach(function (a) {
        return a * a;
    }).diffFree().normalize(0.6, 1);

    var beton = new _buffer2.default(tileSize * 8);
    var betonImg = beton.brick(4, 4).normalize(0.7, 1).forBuf(betonNoise, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([160, 160, 160]));

    var betonMask = new _buffer2.default(tileSize * 8);
    this.beton = betonMask.brickMask(4, 4).gaussian(3).clamp(0.1, 0.3).normalize(0, 1).getColorLerp(betonImg, cementImg);

    // lava
    var lava = new _buffer2.default(tileSize * 8);
    this.lava = lava.perlin(2, 0.5).normalize(0, 30).forEach(Math.cos).normalize(0.5, 1).getColor2((0, _utils.randColor)([255, 0, 0]), (0, _utils.randColor)([255, 255, 0]));

    // grass
    var grass = new _buffer2.default(tileSize * 8);
    grass.perlin(5, 0.5).diffFree().normalize(0.7, 1.3);

    var grassMask = new _buffer2.default(tileSize * 8);
    this.grass = grassMask.perlin(20, 0.9).normalize(0, 1).clamp(0.2, 0.5).normalize(0, 1).getColorAlpha(grassMask, (0, _utils.randColor)([49, 107, 54]));

    // board
    var boardMask = new _buffer2.default(tileSize);
    boardMask.forEach(function () {
        return 1;
    }).bresenham(0, 0, boardMask.size - 1, 0, 0).bresenham(0, boardMask.size - 1, boardMask.size - 1, boardMask.size - 1, 0).bresenham(0, 0, 0, boardMask.size - 1, 0).bresenham(boardMask.size - 1, 0, boardMask.size - 1, boardMask.size - 1, 0).gaussian(2);

    var board = new _buffer2.default(tileSize);
    this.board = board.perlin(2, 0.5).normalize(0.7, 1).forBuf(boardMask, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([188, 198, 204]));

    // Eagle
    var eagle = new _buffer2.default(tileSize * 2);
    var center = eagle.size * 0.5 | 0;
    var step = eagle.size * 0.1 | 0;
    eagle.bresenham(center, center + step, 2 * step, 2 * step, 1).bresenham(center, center + step, eagle.size - 2 * step, 2 * step, 1).bresenham(center, step, center, eagle.size - step, 1).bresenham(center - 2 * step, center + 2 * step, 3 * step, 3 * step, 1).bresenham(center + 2 * step, center + 2 * step, eagle.size - 3 * step, 3 * step, 1).bresenham(center - 2 * step, center + 2 * step, center, center, 1).bresenham(center + 2 * step, center + 2 * step, center, center, 1).gaussian(step).normalize(0, 1).bresenham(center, eagle.size - 2 * step, center - 2 * step, eagle.size - step, 1.5).bresenham(center, eagle.size - 2 * step, center + 2 * step, eagle.size - step, 1.5).bresenham(center, step, center + step * 2, step, 1).bresenham(step * 2, step * 2, step, step, 1.5).bresenham(eagle.size - step * 2, step * 2, eagle.size - step, step, 1.5).bresenham(3 * step, 3 * step, step, 3 * step, 1).bresenham(eagle.size - 3 * step, 3 * step, eagle.size - step, 3 * step, 1).bresenham(4 * step, 4 * step, step, 4 * step, 1).bresenham(eagle.size - 4 * step, 4 * step, eagle.size - step, 4 * step, 1).gaussian(step).normalize(0, 1);

    var eagleMask = new _buffer2.default(tileSize * 2);
    eagleMask.copy(eagle).clamp(0.1, 0.2).normalize(0, 1);

    var eagleColor = new _buffer2.default(tileSize * 2);
    this.eagle = eagleColor.forEach(function () {
        return 1;
    }).bresenham(center, step, center, step, 0).gaussian(step).normalize(0, 1).clamp(0.2, 0.25).normalize(0, 1).forBuf(eagleMask, function (a, b) {
        return a * (10 * (Math.abs(b - 0.5) - 0.5) + 1);
    }).forBuf(eagle, function (a, b) {
        return a - b * 0.5;
    }).getColor2([0, 0, 0], [190, 190, 190], eagleMask);
};

exports.default = GenTextures;
},{"../utils":5,"./buffer":1}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _utils = require("./utils");

var _genTextures = require("./gener/genTextures");

var _genTextures2 = _interopRequireDefault(_genTextures);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Layer = function Layer(width, height) {
    _classCallCheck(this, Layer);

    this.canvas = document.createElement("canvas");
    this.canvas.width = width;
    this.canvas.height = height;
    this.context = this.canvas.getContext("2d");
};

var Level = function Level(levelName, canvas) {
    var _this = this;

    _classCallCheck(this, Level);

    var _getSizeMap = (0, _utils.getSizeMap)(),
        mapWidth = _getSizeMap.mapWidth,
        mapHeight = _getSizeMap.mapHeight;

    var tileWidth = canvas.width / mapWidth | 0;
    var tileHeight = canvas.height / mapHeight | 0;
    var tileSize = Math.min(tileWidth, tileHeight);
    console.log("tileWidth = " + tileWidth + ", tileHeight = " + tileHeight);

    this.textures = new _genTextures2.default(tileSize);
    this.layerGround = new Layer(mapWidth * tileSize, mapHeight * tileSize);
    this.layerBrick = new Layer(mapWidth * tileSize, mapHeight * tileSize);
    this.layerGrass = new Layer(mapWidth * tileSize, mapHeight * tileSize);

    var renderBoard = function renderBoard() {
        for (var i = 0; i < mapWidth; i++) {
            _this.layerGround.context.drawImage(_this.textures.board, i * tileSize, 0);
            _this.layerGround.context.drawImage(_this.textures.board, i * tileSize, (mapHeight - 1) * tileSize);
        }
        for (var _i = 1; _i < mapHeight - 1; _i++) {
            _this.layerGround.context.drawImage(_this.textures.board, 0, _i * tileSize);
            _this.layerGround.context.drawImage(_this.textures.board, (mapWidth - 1) * tileSize, _i * tileSize);
        }
    };
    var renderGround = function renderGround() {
        var ground = _this.textures.ground;

        for (var y = 0; y < _this.layerGround.canvas.height; y += ground.height) {
            for (var x = 0; x < _this.layerGround.canvas.width; x += ground.width) {
                _this.layerGround.context.drawImage(ground, x, y);
            }
        }
    };
    var renderEagle = function renderEagle() {
        _this.layerGround.context.drawImage(_this.textures.eagle, 100, 100);
    };

    var renderTime = Date.now();

    renderGround();
    renderBoard();
    renderEagle();

    this.context = canvas.getContext("2d");
    this.context.drawImage(this.layerGround.canvas, 0, 0);

    console.log("Render time = " + (Date.now() - renderTime));
};

exports.default = Level;
},{"./gener/genTextures":2,"./utils":5}],4:[function(require,module,exports){
"use strict";

var _utils = require("./utils");

var _level = require("./level");

var _level2 = _interopRequireDefault(_level);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Size of map 36x20
function calcSizeForCanvas(width, height) {
    var _getSizeMap = (0, _utils.getSizeMap)(),
        mapWidth = _getSizeMap.mapWidth,
        mapHeight = _getSizeMap.mapHeight;

    var aspect = width / height;
    var mapAspect = mapWidth / (mapHeight + 1); // +1 for UI

    if (mapAspect > aspect) {
        return { width: width, height: width / mapAspect };
    }
    return { width: height * mapAspect, height: height };
}

function main() {
    console.assert = function (condition) {
        var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";

        if (!condition) {
            console.log(message);
            if (typeof Error !== "undefined") {
                throw new Error(message);
            }
            throw message; // Fallback
        }
    };

    var canvas = document.getElementById("canvas");

    var _calcSizeForCanvas = calcSizeForCanvas(window.innerWidth - 40, window.innerHeight - 40),
        width = _calcSizeForCanvas.width,
        height = _calcSizeForCanvas.height;

    canvas.width = width;
    canvas.height = height;

    var level = new _level2.default("test", canvas);
}
window.addEventListener("load", main);
},{"./level":3,"./utils":5}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rand = rand;
exports.clamp = clamp;
exports.randColor = randColor;
exports.getSizeMap = getSizeMap;
function rand(m, radius) {
    return 2 * radius * Math.random() - radius + m;
}

function clamp(a, min, max) {
    return Math.max(min, Math.min(max, a));
}

function randColor(color) {
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    var ret = new Array(3);
    for (var i = 0; i < 3; i++) {
        ret[i] = clamp(rand(color[i], radius), 0, 255);
    }return ret;
}

function getSizeMap() {
    var mapWidth = 36;
    var mapHeight = 20;
    mapWidth += 1 + 1; // for board;
    mapHeight += 1 + 1; // for board;
    return { mapWidth: mapWidth, mapHeight: mapHeight };
}
},{}]},{},[4]);
