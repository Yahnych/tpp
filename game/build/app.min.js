(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("../utils");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleBuffer = function () {
    function SimpleBuffer(size) {
        _classCallCheck(this, SimpleBuffer);

        this.data = new Float32Array(size * size);
        this.size = size;
        this.data.fill(0.0);
    }

    _createClass(SimpleBuffer, [{
        key: "getData",
        value: function getData(x, y) {
            if (x < 0 || x > this.size - 1) return 0.0;
            if (y < 0 || y > this.size - 1) return 0.0;
            return this.data[y * this.size + x | 0];
        }
    }, {
        key: "setData",
        value: function setData(x, y, val) {
            if (x < 0 || x > this.size - 1) return;
            if (y < 0 || y > this.size - 1) return;
            this.data[y * this.size + x | 0] = val;
        }
    }, {
        key: "getColor",
        value: function getColor() {
            var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [255, 255, 255];

            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = col[0] * this.data[i] | 0;
                imageData.data[4 * i + 1] = col[1] * this.data[i] | 0;
                imageData.data[4 * i + 2] = col[2] * this.data[i] | 0;
                imageData.data[4 * i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColorLerp",
        value: function getColorLerp() {
            var col0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
            var col1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 255, 255];

            var lerp = function lerp(a, b, t) {
                return a * (1 - t) + b * t;
            };
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = lerp(col0[0], col1[0], this.data[i]) | 0;
                imageData.data[4 * i + 1] = lerp(col0[1], col1[1], this.data[i]) | 0;
                imageData.data[4 * i + 2] = lerp(col0[2], col1[2], this.data[i]) | 0;
                imageData.data[4 * i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "perlin",
        value: function perlin(startFreq, koef) {
            var _this = this;

            var time = Date.now();
            var extrem = function extrem(freq, ampl) {
                var dispersion = function dispersion(rad) {
                    return (0, _utils.rand)(0, rad);
                };

                var ret = new Array(freq * freq);
                for (var i = 0; i < freq * freq; i++) {
                    ret[i] = dispersion(ampl);
                }
                return ret;
            };
            var cosLerp = function cosLerp(a, b, t) {
                var ft = t * Math.PI;
                var f = (1 - Math.cos(ft)) * 0.5;
                return a * (1 - f) + b * f;
            };

            var ampl = 1;
            var freq = startFreq;

            var _loop = function _loop() {
                var buf = extrem(freq, ampl);
                var bufData = function bufData(x, y) {
                    return buf[y * freq + x | 0];
                };

                for (var j = 0; j < _this.size; j++) {
                    for (var i = 0; i < _this.size; i++) {
                        var x = i * freq / _this.size | 0;
                        var y = j * freq / _this.size | 0;
                        var tx = i * freq / _this.size - x;
                        var ty = j * freq / _this.size - y;
                        var x1 = bufData(x, y);
                        var oldX = x;
                        x++;
                        if (x > freq - 1) x = 0;
                        var x2 = bufData(x, y);
                        var xx = cosLerp(x1, x2, tx);

                        y++;
                        if (y > freq - 1) y = 0;
                        var y1 = bufData(oldX, y);
                        var y2 = bufData(x, y);
                        var yy = cosLerp(y1, y2, tx);
                        var h = cosLerp(xx, yy, ty);

                        _this.data[_this.size * j + i | 0] += h;
                    }
                }
                freq *= 2;
                ampl *= koef;
            };

            do {
                _loop();
            } while (freq < this.size);

            console.log("Perlin noise = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normalize",
        value: function normalize(a, b) {
            var time = Date.now();
            var min = this.data[0];
            var max = this.data[0];
            for (var i = 1; i < this.size * this.size; i++) {
                max = Math.max(max, this.data[i]);
                min = Math.min(min, this.data[i]);
            }
            var k = (b - a) / (max - min);
            for (var _i = 0; _i < this.size * this.size; _i++) {
                this.data[_i] = (this.data[_i] - min) * k + a;
            }
            console.log("Normalize = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forEach",
        value: function forEach(fun) {
            var time = Date.now();
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], i, j);
                }
            }
            console.log("For each = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forBuf",
        value: function forBuf(buf, fun) {
            var time = Date.now();
            console.assert(this.size === buf.size, "Sizes of buffers must be equal");
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], buf.data[ind], i, j);
                }
            }
            console.log("For buffer = ", Date.now() - time);
            return this;
        }
    }, {
        key: "clamp",
        value: function clamp(a, b) {
            var time = Date.now();
            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = Math.max(a, Math.min(b, this.data[i]));
            }
            console.log("Clamp = ", Date.now() - time);
            return this;
        }
    }, {
        key: "gaussianFast",
        value: function gaussianFast(srcBuf, radius, dir) {
            var time = Date.now();
            console.assert(this.size === srcBuf.size, "Sizes of buffers must be equal");
            console.assert(this !== srcBuf, "Source buffer must does not be same with this");

            var norm = function norm(x) {
                var a = 1 / Math.sqrt(2 * Math.PI);
                var b = -x * x / 2;
                return a * Math.exp(b);
            };

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var kol = 0.0;
                    var sum = 0.0;
                    for (var p = -radius; p <= radius; p++) {
                        var x = i + dir[0] * p;
                        var y = j + dir[1] * p;
                        if (x >= this.size || y >= this.size) break;
                        if (y >= 0 && x >= 0) {
                            var sx = (x - i) / radius;
                            var sy = (y - j) / radius;
                            var r = Math.sqrt(sx * sx + sy * sy);
                            var koef = norm(r * 3);
                            kol += koef;
                            sum += koef * srcBuf.data[y * this.size + x | 0];
                        }
                    }
                    var ind = i + j * this.size | 0;
                    this.data[ind] = sum / kol;
                }
            }
            console.log("Gaussian fast = ", Date.now() - time);
        }
    }, {
        key: "gaussian",
        value: function gaussian(radius) {
            var blur = new SimpleBuffer(this.size);
            blur.gaussianFast(this, radius, [1, 0]);
            this.gaussianFast(blur, radius, [0, 1]);
            return this;
        }
    }, {
        key: "copy",
        value: function copy(src) {
            var time = Date.now();
            console.assert(this.size === src.size, "Sizes of buffers must be equal");
            console.assert(this !== src, "Source buffer must does not be same with this");

            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = src.data[i];
            }

            console.log("Copy = ", Date.now() - time);
        }
    }, {
        key: "bresenham",
        value: function bresenham(x0, y0, x1, y1, val) {
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var sx = x0 < x1 ? 1 : -1;
            var sy = y0 < y1 ? 1 : -1;
            var err = (dx > dy ? dx : -dy) / 2;
            var x = x0;
            var y = y0;

            for (;;) {
                if (x >= 0 && x < this.size && y >= 0 && y < this.size) {
                    this.setData(x, y, val);
                }
                if (x === x1 && y === y1) break;
                var e2 = err;
                if (e2 > -dx) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dy) {
                    err += dx;
                    y += sy;
                }
            }
            return this;
        }
    }, {
        key: "differential",
        value: function differential(fun) {
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var nx = i + 1;
                    var ny = j + 1;
                    if (nx > this.size - 1) nx = 0;
                    if (ny > this.size - 1) ny = 0;
                    var ind00 = j * this.size + i;
                    var ind01 = ny * this.size + i;
                    var ind10 = j * this.size + nx;
                    var col00 = this.data[ind00];
                    var col01 = this.data[ind01];
                    var col10 = this.data[ind10];
                    var dx = (col10 - col00) * 0.5;
                    var dy = (col01 - col00) * 0.5;
                    fun(ind00, dx, dy);
                }
            }
        }
    }, {
        key: "diff",
        value: function diff(dir) {
            var _this2 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this2.data[ind] = dx * dir[0] + dy * dir[1];
            });

            console.log("Differential", Date.now() - time);
            return this;
        }
    }, {
        key: "diffFree",
        value: function diffFree() {
            var _this3 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this3.data[ind] = Math.sqrt(dx * dx + dy * dy);
            });

            console.log("Differential free", Date.now() - time);
            return this;
        }
    }, {
        key: "brick",
        value: function brick(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                var startY = brickY * brickHeight | 0;
                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var color = Math.random();
                    var X = startX + brickX * brickWidth | 0;
                    for (var j = startY; j < startY + brickHeight; j++) {
                        if (j > this.size - 1) break;
                        for (var i = X; i < X + brickWidth; i++) {
                            var x = i < 0 ? this.size + i : i;
                            this.data[j * this.size + x] = color;
                        }
                    }
                }
            }

            console.log("Brick generate", Date.now() - time);
            return this;
        }
    }]);

    return SimpleBuffer;
}();

exports.default = SimpleBuffer;
},{"../utils":3}],2:[function(require,module,exports){
"use strict";

var _buffer = require("./gener/buffer");

var _buffer2 = _interopRequireDefault(_buffer);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function calcSizeMap() {
    var mapWidth = 36;
    var mapHeight = 20;
    mapWidth += 1 + 1; // for board;
    mapHeight += 1 + 1 + 1; // for board and UI
    return { mapWidth: mapWidth, mapHeight: mapHeight };
}

// Size of map 36x20
function calcSizeForCanvas(width, height) {
    var _calcSizeMap = calcSizeMap(),
        mapWidth = _calcSizeMap.mapWidth,
        mapHeight = _calcSizeMap.mapHeight;

    var aspect = width / height;
    var mapAspect = mapWidth / mapHeight;

    if (mapAspect > aspect) {
        return { width: width, height: width / mapAspect };
    }
    return { width: height * mapAspect, height: height };
}

function main() {
    console.assert = function (condition) {
        var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";

        if (!condition) {
            console.log(message);
            if (typeof Error !== "undefined") {
                throw new Error(message);
            }
            throw message; // Fallback
        }
    };

    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");

    var _calcSizeForCanvas = calcSizeForCanvas(window.innerWidth - 40, window.innerHeight - 40),
        width = _calcSizeForCanvas.width,
        height = _calcSizeForCanvas.height;

    canvas.width = width;
    canvas.height = height;

    // const ground = new SimpleBuffer(512);
    // const groundImg = ground
    //     .perlin(5, 0.5)
    //     .diff([1, 0.5])
    //     .normalize(0.75, 1)
    //     .getColor(randColor([224, 207, 159], 20));

    var buffer = new _buffer2.default(512);
    var image = buffer
    // .perlin(5, 0.5)
    // // .normalize(0, 50)
    // .forEach((val) => 1 / (val * val + 1))
    // // .diffFree()
    // .diff([1, 0.5])
    // // .diff([-0.5, 1])
    .brick(10, 20).normalize(0.75, 1).getColor((0, _utils.randColor)([160, 54, 35], 10));
    context.drawImage(image, 100, 100);
    context.drawImage(image, 100 + image.width, 100);
}
window.addEventListener("load", main);
},{"./gener/buffer":1,"./utils":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rand = rand;
exports.randColor = randColor;
function rand(m, radius) {
    return 2 * radius * Math.random() - radius + m;
}

function randColor(color, radius) {
    return [rand(color[0], radius), rand(color[1], radius), rand(color[2], radius)];
}
},{}]},{},[2]);
