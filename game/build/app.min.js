(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require("../utils");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lerp(a, b, t) {
    return a * (1 - t) + b * t;
}

function norm(x) {
    var a = 1 / Math.sqrt(2 * Math.PI);
    var b = -x * x / 2;
    return a * Math.exp(b);
}

var SimpleBuffer = function () {
    function SimpleBuffer(size) {
        _classCallCheck(this, SimpleBuffer);

        this.data = new Float32Array(size * size);
        this.size = size;
        this.data.fill(0.0);
    }

    _createClass(SimpleBuffer, [{
        key: "getData",
        value: function getData(x, y) {
            if (x < 0 || x > this.size - 1) return 0.0;
            if (y < 0 || y > this.size - 1) return 0.0;
            return this.data[y * this.size + x | 0];
        }
    }, {
        key: "setData",
        value: function setData(x, y, val) {
            if (x < 0 || x > this.size - 1) return;
            if (y < 0 || y > this.size - 1) return;
            this.data[y * this.size + x | 0] = val;
        }
    }, {
        key: "getColor",
        value: function getColor() {
            var col = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [255, 255, 255];
            var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            console.assert(!mask || mask.size === this.size, "Require same size");
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = col[0] * this.data[i] | 0;
                imageData.data[4 * i + 1] = col[1] * this.data[i] | 0;
                imageData.data[4 * i + 2] = col[2] * this.data[i] | 0;
                imageData.data[4 * i + 3] = mask ? mask.data[i] * 255 | 0 : 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColor2",
        value: function getColor2() {
            var col0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
            var col1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 255, 255];
            var mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            console.assert(!mask || mask.size === this.size, "Require same size");
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = (0, _utils.clamp)(lerp(col0[0], col1[0], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 1] = (0, _utils.clamp)(lerp(col0[1], col1[1], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 2] = (0, _utils.clamp)(lerp(col0[2], col1[2], this.data[i]), 0, 255) | 0;
                imageData.data[4 * i + 3] = mask ? mask.data[i] * 255 | 0 : 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "getColorLerp",
        value: function getColorLerp(img0, img1) {
            console.assert(img0.width === img1.width, "Require same image");
            console.assert(img0.height === img1.height, "Require same image");
            console.assert(img0.width === this.size, "Require same image");
            console.assert(img0.height === this.size, "Require same image");

            var data0 = img0.getContext("2d").getImageData(0, 0, this.size, this.size).data;
            var data1 = img1.getContext("2d").getImageData(0, 0, this.size, this.size).data;
            var canvas = document.createElement("canvas");
            canvas.width = this.size;
            canvas.height = this.size;
            var context = canvas.getContext("2d");
            var imageData = context.createImageData(this.size, this.size);
            for (var i = 0; i < this.size * this.size; i++) {
                imageData.data[4 * i + 0] = lerp(data0[4 * i + 0], data1[4 * i + 0], this.data[i]) | 0;
                imageData.data[4 * i + 1] = lerp(data0[4 * i + 1], data1[4 * i + 1], this.data[i]) | 0;
                imageData.data[4 * i + 2] = lerp(data0[4 * i + 2], data1[4 * i + 2], this.data[i]) | 0;
                imageData.data[4 * i + 3] = 255;
            }
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
    }, {
        key: "perlin",
        value: function perlin(startFreq, koef) {
            var _this = this;

            var time = Date.now();
            var extrem = function extrem(freq, ampl) {
                var dispersion = function dispersion(rad) {
                    return (0, _utils.rand)(0, rad);
                };

                var ret = new Array(freq * freq);
                for (var i = 0; i < freq * freq; i++) {
                    ret[i] = dispersion(ampl);
                }
                return ret;
            };
            var cosLerp = function cosLerp(a, b, t) {
                var ft = t * Math.PI;
                var f = (1 - Math.cos(ft)) * 0.5;
                return a * (1 - f) + b * f;
            };

            var ampl = 1;
            var freq = startFreq;

            var _loop = function _loop() {
                var buf = extrem(freq, ampl);
                var bufData = function bufData(x, y) {
                    return buf[y * freq + x | 0];
                };

                for (var j = 0; j < _this.size; j++) {
                    for (var i = 0; i < _this.size; i++) {
                        var x = i * freq / _this.size | 0;
                        var y = j * freq / _this.size | 0;
                        var tx = i * freq / _this.size - x;
                        var ty = j * freq / _this.size - y;
                        var x1 = bufData(x, y);
                        var oldX = x;
                        x++;
                        if (x > freq - 1) x = 0;
                        var x2 = bufData(x, y);
                        var xx = cosLerp(x1, x2, tx);

                        y++;
                        if (y > freq - 1) y = 0;
                        var y1 = bufData(oldX, y);
                        var y2 = bufData(x, y);
                        var yy = cosLerp(y1, y2, tx);
                        var h = cosLerp(xx, yy, ty);

                        _this.data[_this.size * j + i | 0] += h;
                    }
                }
                freq *= 2;
                ampl *= koef;
            };

            do {
                _loop();
            } while (freq < this.size);

            console.log("Perlin noise = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normalize",
        value: function normalize(a, b) {
            var time = Date.now();
            var min = this.data[0];
            var max = this.data[0];
            for (var i = 1; i < this.size * this.size; i++) {
                max = Math.max(max, this.data[i]);
                min = Math.min(min, this.data[i]);
            }
            var k = (b - a) / (max - min);
            for (var _i = 0; _i < this.size * this.size; _i++) {
                this.data[_i] = (this.data[_i] - min) * k + a;
            }
            console.log("Normalize = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forEach",
        value: function forEach(fun) {
            var time = Date.now();
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], i, j);
                }
            }
            console.log("For each = ", Date.now() - time);
            return this;
        }
    }, {
        key: "forBuf",
        value: function forBuf(buf, fun) {
            var time = Date.now();
            console.assert(this.size === buf.size, "Sizes of buffers must be equal");
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var ind = j * this.size + i | 0;
                    this.data[ind] = fun(this.data[ind], buf.data[ind], i, j);
                }
            }
            console.log("For buffer = ", Date.now() - time);
            return this;
        }
    }, {
        key: "clamp",
        value: function clamp(a, b) {
            var time = Date.now();
            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = (0, _utils.clamp)(this.data[i], a, b);
            }
            console.log("Clamp = ", Date.now() - time);
            return this;
        }
    }, {
        key: "gaussianFast",
        value: function gaussianFast(srcBuf, radius, dir) {
            var time = Date.now();
            console.assert(this.size === srcBuf.size, "Sizes of buffers must be equal");
            console.assert(this !== srcBuf, "Source buffer must does not be same with this");

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var kol = 0.0;
                    var sum = 0.0;
                    for (var p = -radius; p <= radius; p++) {
                        var x = i + dir[0] * p;
                        var y = j + dir[1] * p;

                        var sx = (x - i) / radius;
                        var sy = (y - j) / radius;
                        var r = Math.sqrt(sx * sx + sy * sy);
                        var koef = norm(r * 3);
                        kol += koef;

                        if (x < 0) x += this.size;
                        if (y < 0) y += this.size;
                        if (x > this.size - 1) x -= this.size;
                        if (y > this.size - 1) y -= this.size;

                        sum += koef * srcBuf.data[y * this.size + x | 0];
                    }
                    var ind = i + j * this.size | 0;
                    this.data[ind] = sum / kol;
                }
            }
            console.log("Gaussian fast = ", Date.now() - time);
        }
    }, {
        key: "gaussian",
        value: function gaussian(radius) {
            var blur = new SimpleBuffer(this.size);
            blur.gaussianFast(this, radius, [1, 0]);
            this.gaussianFast(blur, radius, [0, 1]);
            return this;
        }
    }, {
        key: "copy",
        value: function copy(src) {
            var time = Date.now();
            console.assert(this.size === src.size, "Sizes of buffers must be equal");
            console.assert(this !== src, "Source buffer must does not be same with this");

            for (var i = 0; i < this.size * this.size; i++) {
                this.data[i] = src.data[i];
            }

            console.log("Copy = ", Date.now() - time);
            return this;
        }
    }, {
        key: "bresenham",
        value: function bresenham(x0, y0, x1, y1, val) {
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var sx = x0 < x1 ? 1 : -1;
            var sy = y0 < y1 ? 1 : -1;
            var err = (dx > dy ? dx : -dy) / 2;
            var x = x0;
            var y = y0;

            for (;;) {
                this.setData(x, y, val);
                if (x === x1 && y === y1) break;
                var e2 = err;
                if (e2 > -dx) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dy) {
                    err += dx;
                    y += sy;
                }
            }
            return this;
        }
    }, {
        key: "differential",
        value: function differential(fun) {
            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var nx = i + 1;
                    var ny = j + 1;
                    if (nx > this.size - 1) nx = 0;
                    if (ny > this.size - 1) ny = 0;
                    var ind00 = j * this.size + i;
                    var ind01 = ny * this.size + i;
                    var ind10 = j * this.size + nx;
                    var col00 = this.data[ind00];
                    var col01 = this.data[ind01];
                    var col10 = this.data[ind10];
                    var dx = (col10 - col00) * 0.5;
                    var dy = (col01 - col00) * 0.5;
                    fun(ind00, dx, dy);
                }
            }
        }
    }, {
        key: "diff",
        value: function diff(dir) {
            var _this2 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this2.data[ind] = dx * dir[0] + dy * dir[1];
            });

            console.log("Differential", Date.now() - time);
            return this;
        }
    }, {
        key: "diffFree",
        value: function diffFree() {
            var _this3 = this;

            var time = Date.now();

            var buf = new SimpleBuffer(this.size);
            buf.copy(this);
            buf.differential(function (ind, dx, dy) {
                _this3.data[ind] = Math.sqrt(dx * dx + dy * dy);
            });

            console.log("Differential free", Date.now() - time);
            return this;
        }
    }, {
        key: "brick",
        value: function brick(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                var startY = brickY * brickHeight | 0;
                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var color = Math.random();
                    var X = startX + brickX * brickWidth | 0;
                    for (var j = startY; j < startY + brickHeight; j++) {
                        if (j > this.size - 1) break;
                        for (var i = X; i < X + brickWidth; i++) {
                            var x = i < 0 ? this.size + i : i;
                            this.data[j * this.size + x] = color;
                        }
                    }
                }
            }

            console.log("Brick generate", Date.now() - time);
            return this;
        }
    }, {
        key: "brickMask",
        value: function brickMask(countWidth, countHeight) {
            var time = Date.now();

            var brickWidth = this.size / countWidth;
            var brickHeight = this.size / countHeight;

            for (var brickY = 0; brickY < countHeight; brickY++) {
                var y = brickY * brickHeight | 0;
                var startX = brickY % 2 | 0 ? -brickWidth * 0.5 | 0 : 0;
                this.bresenham(0, y, this.size, y, 1);

                for (var brickX = 0; brickX < countWidth; brickX++) {
                    var x = startX + brickX * brickWidth | 0;
                    if (x < 0) x += this.size;
                    this.bresenham(x, y, x, y + brickHeight | 0, 1);
                }
            }

            console.log("Brick mask generate", Date.now() - time);
            return this;
        }
    }, {
        key: "normDist",
        value: function normDist(rad) {
            var time = Date.now();

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var x = (i - this.size * 0.5) / (rad * this.size * 0.5);
                    var y = (j - this.size * 0.5) / (rad * this.size * 0.5);
                    var r = Math.sqrt(x * x + y * y);
                    var koef = norm(r * 3);
                    this.data[j * this.size + i] = koef;
                }
            }

            console.log("Normal distribution = ", Date.now() - time);
            return this;
        }
    }, {
        key: "normSquare",
        value: function normSquare(minRad, rad) {
            var time = Date.now();

            for (var j = 0; j < this.size; j++) {
                for (var i = 0; i < this.size; i++) {
                    var x = (i - this.size * 0.5) / (this.size * 0.5);
                    var y = (j - this.size * 0.5) / (this.size * 0.5);
                    var r = 0;
                    if (Math.abs(x) > minRad && Math.abs(y) > minRad) {
                        var sx = Math.abs(x) - minRad;
                        var sy = Math.abs(y) - minRad;
                        r = Math.sqrt(sx * sx + sy * sy);
                    } else if (Math.abs(x) > minRad) r = Math.abs(x) - minRad;else if (Math.abs(y) > minRad) r = Math.abs(y) - minRad;
                    r /= rad;
                    var koef = norm(r * 3);
                    this.data[j * this.size + i] = koef;
                }
            }

            console.log("Normal distribution for square pattern = ", Date.now() - time);
            return this;
        }
    }]);

    return SimpleBuffer;
}();

exports.default = SimpleBuffer;
},{"../utils":5}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _buffer = require("./buffer");

var _buffer2 = _interopRequireDefault(_buffer);

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GenTextures = function GenTextures(tileSize) {
    var _this = this;

    _classCallCheck(this, GenTextures);

    // ground
    var ground = new _buffer2.default(tileSize * 8);
    this.ground = ground.perlin(5, 0.9).normalize(0.75, 1).getColor((0, _utils.randColor)([224, 207, 159]));

    // brick
    var cement = new _buffer2.default(tileSize * 8);
    var cementImg = cement.perlin(5, 0.5).diff([1, 0.5]).diff([-0.5, 1]).normalize(0, 1).getColor((0, _utils.randColor)([100, 100, 100]));

    var noise = new _buffer2.default(tileSize * 8);
    noise.perlin(5, 0.5).diff([1, 0.5]).normalize(0, 1);

    var brick = new _buffer2.default(tileSize * 8);
    var brickImg = brick.brick(8, 16).forBuf(noise, function (a, b) {
        return a * b;
    }).normalize(0.7, 1).getColor((0, _utils.randColor)([200, 80, 60]));

    var brickMask = new _buffer2.default(tileSize * 8);
    this.brick = brickMask.brickMask(8, 16).gaussian(3).clamp(0.1, 0.3).normalize(0, 1).getColorLerp(brickImg, cementImg);

    // beton
    var betonNoise = new _buffer2.default(tileSize * 8);
    betonNoise.perlin(5, 0.5).forEach(function (a) {
        return a * a;
    }).diffFree().normalize(0.6, 1);

    var beton = new _buffer2.default(tileSize * 8);
    var betonImg = beton.brick(4, 4).normalize(0.7, 1).forBuf(betonNoise, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([160, 160, 160]));

    var betonMask = new _buffer2.default(tileSize * 8);
    this.beton = betonMask.brickMask(4, 4).gaussian(3).clamp(0.1, 0.3).normalize(0, 1).getColorLerp(betonImg, cementImg);

    // lava
    var lava = new _buffer2.default(tileSize * 8);
    this.lava = lava.perlin(10, 0.5).normalize(0, 30).forEach(Math.cos).normalize(0.5, 1).getColor2((0, _utils.randColor)([255, 0, 0]), (0, _utils.randColor)([255, 255, 0]));

    this.lavaMask = new Array(8);
    this.lavaLightMask = new Array(8);
    for (var i = 0; i < this.lavaMask.length; i++) {
        var lavaNoise = new _buffer2.default(tileSize * 2);
        lavaNoise.perlin(5, 0.5);

        var lavaMask = new _buffer2.default(tileSize * 2);
        this.lavaMask[i] = lavaMask.normSquare(0.4, 0.5).normalize(0, 1).forBuf(lavaNoise, function (a, b) {
            return a + 0.25 * b;
        }).clamp(0.4, 0.6).normalize(0, 1).getColor([255, 255, 255], lavaMask);

        var lavaLightMask = new _buffer2.default(tileSize * 2);
        this.lavaLightMask[i] = lavaLightMask.normSquare(0.4, 0.5).normalize(0, 1.5).forBuf(lavaNoise, function (a, b) {
            return a + 0.25 * b;
        }).clamp(0.25, 0.75).gaussian(7).normalize(0, 1).getColor([0, 0, 0], lavaLightMask);
    }

    // grass
    var grass = new _buffer2.default(tileSize * 8);
    this.grass = grass.perlin(5, 0.5).diffFree().normalize(0.7, 1.3).getColor((0, _utils.randColor)([49, 107, 54]));

    this.grassMask = new Array(8);
    for (var _i = 0; _i < this.grassMask.length; _i++) {
        var normDist = new _buffer2.default(tileSize * 2);
        normDist.normDist(1.25).normalize(0, 3).clamp(0, 1);

        var grassMask = new _buffer2.default(tileSize * 2);
        this.grassMask[_i] = grassMask.perlin(20, 0.9).normalize(0, 1).forBuf(normDist, function (a, b) {
            return a * b;
        }).clamp(0.2, 0.5).normalize(0, 1).getColor((0, _utils.randColor)([255, 255, 255]), grassMask);
    }

    // board
    var boardMask = new _buffer2.default(tileSize);
    boardMask.forEach(function () {
        return 1;
    }).bresenham(0, 0, boardMask.size - 1, 0, 0).bresenham(0, boardMask.size - 1, boardMask.size - 1, boardMask.size - 1, 0).bresenham(0, 0, 0, boardMask.size - 1, 0).bresenham(boardMask.size - 1, 0, boardMask.size - 1, boardMask.size - 1, 0).gaussian(2);

    var board = new _buffer2.default(tileSize);
    this.board = board.perlin(2, 0.5).normalize(0.7, 1).forBuf(boardMask, function (a, b) {
        return a * b;
    }).getColor((0, _utils.randColor)([188, 198, 204]));

    // Eagle
    var eagle = new _buffer2.default(tileSize * 2);
    var center = eagle.size * 0.5 | 0;
    var step = eagle.size * 0.1 | 0;
    eagle.bresenham(center, center + step, 2 * step, 2 * step, 1).bresenham(center, center + step, eagle.size - 2 * step, 2 * step, 1).bresenham(center, step, center, eagle.size - step, 1).bresenham(center - 2 * step, center + 2 * step, 3 * step, 3 * step, 1).bresenham(center + 2 * step, center + 2 * step, eagle.size - 3 * step, 3 * step, 1).bresenham(center - 2 * step, center + 2 * step, center, center, 1).bresenham(center + 2 * step, center + 2 * step, center, center, 1).gaussian(step).normalize(0, 1).bresenham(center, eagle.size - 2 * step, center - 2 * step, eagle.size - step, 1.5).bresenham(center, eagle.size - 2 * step, center + 2 * step, eagle.size - step, 1.5).bresenham(center, step, center + step * 2, step, 1).bresenham(step * 2, step * 2, step, step, 1.5).bresenham(eagle.size - step * 2, step * 2, eagle.size - step, step, 1.5).bresenham(3 * step, 3 * step, step, 3 * step, 1).bresenham(eagle.size - 3 * step, 3 * step, eagle.size - step, 3 * step, 1).bresenham(4 * step, 4 * step, step, 4 * step, 1).bresenham(eagle.size - 4 * step, 4 * step, eagle.size - step, 4 * step, 1).gaussian(step).normalize(0, 1);

    var eagleMask = new _buffer2.default(eagle.size);
    eagleMask.copy(eagle).clamp(0.1, 0.2).normalize(0, 1);

    var eagleColor = new _buffer2.default(eagle.size);
    this.eagle = eagleColor.forEach(function () {
        return 1;
    }).bresenham(center, step, center, step, 0).gaussian(step).normalize(0, 1).clamp(0.2, 0.25).normalize(0, 1).forBuf(eagleMask, function (a, b) {
        return a * (5 * (Math.abs(b - 0.5) - 0.5) + 1);
    }).forBuf(eagle, function (a, b) {
        return a + b * 0.5;
    }).getColor2([0, 0, 0], [128, 128, 128], eagleMask);

    // Bridge
    this.bridgeV = new Array(8);

    var _loop = function _loop(k) {
        var bridgeMaskV = new _buffer2.default(tileSize * 2);
        bridgeMaskV.perlin(5, 0.5).forEach(function (a, i, j) {
            var x = (i / bridgeMaskV.size - 0.5) * 2;
            var y = (j / bridgeMaskV.size - 0.5) * 2;
            var factorX = Math.abs(x) < 0.4 ? 1 : 0;
            var factorY = (0, _utils.clamp)(2 - 2 * Math.abs(y), 0, 1);
            factorY += 0.25 * a;
            factorY = ((0, _utils.clamp)(factorY, 0.3, 0.4) - 0.3) * 10;
            return factorX * factorY;
        });

        var bridgeV = new _buffer2.default(tileSize * 2);
        _this.bridgeV[k] = bridgeV.perlin(5, 0.5).forEach(function (a) {
            return a * a;
        }).diffFree().normalize(0.5, 1.5).forEach(function (a, i) {
            var x = i / bridgeV.size * Math.PI * 8;
            return a * Math.abs(Math.cos(x));
        }).forBuf(bridgeMaskV, function (a, b) {
            return a * b * b;
        }).normalize(0.5, 1).getColor((0, _utils.randColor)([182, 155, 76]), bridgeMaskV);
    };

    for (var k = 0; k < this.bridgeV.length; k++) {
        _loop(k);
    }
};

exports.default = GenTextures;
},{"../utils":5,"./buffer":1}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Level = exports.TileType = undefined;

var _utils = require("./utils");

var _genTextures = require("./gener/genTextures");

var _genTextures2 = _interopRequireDefault(_genTextures);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Layer = function Layer(width, height) {
    _classCallCheck(this, Layer);

    this.canvas = document.createElement("canvas");
    this.canvas.width = width;
    this.canvas.height = height;
    this.context = this.canvas.getContext("2d");
};

var EMPTY = 0;
var HALF = 1;
var BRICK = 2;
var BETON = 4;
var WATER = 8;
var GRASS = 16;
var BRIDGEH = 32;
var BRIDGEV = 64;
var BRIDGE = BRIDGEH | BRIDGEV;
var EAGLE = 128;
var MOVE_MASK = HALF | BRICK | BETON | WATER | EAGLE;
var BULLET_MASK = HALF | BRICK | BETON | EAGLE;

var TileType = exports.TileType = {
    EMPTY: EMPTY,
    HALF: HALF,
    BRICK: BRICK,
    BETON: BETON,
    WATER: WATER,
    GRASS: GRASS,
    BRIDGEH: BRIDGEH,
    BRIDGEV: BRIDGEV,
    BRIDGE: BRIDGE,
    EAGLE: EAGLE,
    MOVE_MASK: MOVE_MASK,
    BULLET_MASK: BULLET_MASK
};

var Level = exports.Level = function Level(levelName, canvas) {
    var _this = this;

    _classCallCheck(this, Level);

    var _getSizeMap = (0, _utils.getSizeMap)(),
        mapWidth = _getSizeMap.mapWidth,
        mapHeight = _getSizeMap.mapHeight;

    var tileWidth = canvas.width / mapWidth | 0;
    var tileHeight = canvas.height / mapHeight | 0;
    var tileSize = Math.min(tileWidth, tileHeight);
    console.log("tileWidth = " + tileWidth + ", tileHeight = " + tileHeight);

    this.textures = new _genTextures2.default(tileSize);
    this.layerGround = new Layer(mapWidth * tileSize, mapHeight * tileSize);
    this.layerLava = new Layer(mapWidth * tileSize, mapHeight * tileSize);
    this.layerBrick = new Layer(mapWidth * tileSize, mapHeight * tileSize);
    this.layerGrass = new Layer(mapWidth * tileSize, mapHeight * tileSize);

    var renderBoard = function renderBoard() {
        // render horizontal board
        for (var i = 0; i < mapWidth; i++) {
            _this.layerGround.context.drawImage(_this.textures.board, i * tileSize, 0);
            _this.layerGround.context.drawImage(_this.textures.board, i * tileSize, (mapHeight - 1) * tileSize);
        }
        // render vertical board
        for (var _i = 1; _i < mapHeight - 1; _i++) {
            _this.layerGround.context.drawImage(_this.textures.board, 0, _i * tileSize);
            _this.layerGround.context.drawImage(_this.textures.board, (mapWidth - 1) * tileSize, _i * tileSize);
        }
    };
    var renderTexture = function renderTexture(destLayer, texture) {
        for (var y = 0; y < destLayer.canvas.height; y += texture.height) {
            for (var x = 0; x < destLayer.canvas.width; x += texture.width) {
                destLayer.context.drawImage(texture, x, y);
            }
        }
    };
    var renderEagle = function renderEagle() {
        var posX = ((mapWidth / 2 | 0) - 1) * tileSize;
        var posY = (mapHeight - 3) * tileSize;
        _this.layerGround.context.drawImage(_this.textures.eagle, posX, posY);
    };
    var calcTilePos = function calcTilePos(index, minusHalf) {
        var x = 1 + index % (mapWidth - 2) | 0;
        var y = 1 + index / (mapWidth - 2) | 0;
        var posX = x * tileSize;
        var posY = y * tileSize;
        if (minusHalf) {
            posX -= tileSize / 2 | 0;
            posY -= tileSize / 2 | 0;
        }
        return { posX: posX, posY: posY };
    };
    var renderLava = function renderLava() {
        var oldGround = _this.layerGround.context.globalCompositeOperation;
        _this.layerGround.context.globalCompositeOperation = "multiply";

        _this.map.forEach(function (tile, index) {
            if (tile & (WATER | BRIDGE)) {
                var _calcTilePos = calcTilePos(index, true),
                    posX = _calcTilePos.posX,
                    posY = _calcTilePos.posY;

                var ind = Math.random() * _this.textures.lavaMask.length | 0;
                _this.layerLava.context.drawImage(_this.textures.lavaMask[ind], posX, posY);
                _this.layerGround.context.drawImage(_this.textures.lavaLightMask[ind], posX, posY);
            }
        });

        var oldLava = _this.layerLava.context.globalCompositeOperation;
        _this.layerLava.context.globalCompositeOperation = "source-atop";

        renderTexture(_this.layerLava, _this.textures.lava);

        _this.layerGround.context.globalCompositeOperation = oldGround;
        _this.layerLava.context.globalCompositeOperation = oldLava;
    };
    var renderBridge = function renderBridge() {
        _this.map.forEach(function (tile, index) {
            if (tile === BRIDGEV) {
                var _calcTilePos2 = calcTilePos(index, true),
                    posX = _calcTilePos2.posX,
                    posY = _calcTilePos2.posY;

                var ind = Math.random() * _this.textures.bridgeV.length | 0;
                _this.layerLava.context.drawImage(_this.textures.bridgeV[ind], posX, posY);
            }
        });
    };
    var renderBrick = function renderBrick() {
        _this.map.forEach(function (tile, index) {
            if (tile & (BRICK | BETON)) {
                var _calcTilePos3 = calcTilePos(index, false),
                    posX = _calcTilePos3.posX,
                    posY = _calcTilePos3.posY;

                var img = tile & BRICK ? _this.textures.brick : _this.textures.beton;
                var srcX = posX % img.width | 0;
                var srcY = posY % img.height | 0;
                _this.layerBrick.context.drawImage(img, srcX, srcY, tileSize, tileSize, posX, posY, tileSize, tileSize);
            }
        });
    };
    var renderGrass = function renderGrass() {
        _this.map.forEach(function (tile, index) {
            if (tile === GRASS) {
                var _calcTilePos4 = calcTilePos(index, true),
                    posX = _calcTilePos4.posX,
                    posY = _calcTilePos4.posY;

                var ind = Math.random() * _this.textures.lavaMask.length | 0;
                _this.layerGrass.context.drawImage(_this.textures.grassMask[ind], posX, posY);
            }
        });

        var oldGrass = _this.layerGrass.context.globalCompositeOperation;
        _this.layerGrass.context.globalCompositeOperation = "source-atop";

        renderTexture(_this.layerGrass, _this.textures.grass);

        _this.layerGrass.context.globalCompositeOperation = oldGrass;
    };

    var loadLevel = function loadLevel(callback) {
        console.log("Loading " + levelName + ".tmx level");
        var reader = new XMLHttpRequest();
        reader.open("get", levelName + ".tmx", true);
        reader.onload = function () {
            var parser = new DOMParser();
            var xml = parser.parseFromString(reader.responseText, "text/xml");

            console.assert(xml.children.length === 1, "Count children must bu 1");

            var attrs = xml.children[0].attributes;
            console.assert(attrs.width.textContent === "" + (mapWidth - 2));
            console.assert(attrs.height.textContent === "" + (mapHeight - 2));
            console.assert(xml.children[0].children.length === 2, "Should be tileset and layer");
            console.assert(xml.children[0].children[1].children.length === 1, "Should be data");

            var data = xml.children[0].children[1].children[0].innerHTML.split(/\s|,/).filter(function (val) {
                return val !== "";
            }).map(function (val) {
                return parseInt(val, 10);
            });
            console.assert(data.length === (mapWidth - 2) * (mapHeight - 2), "Wrong count tiles");

            _this.map = data.map(function (val) {
                switch (val) {
                    case 0:
                        return EMPTY;
                    case 1:
                        return BRICK;
                    case 2:
                        return BETON;
                    case 3:
                        return WATER;
                    case 4:
                        return GRASS;
                    case 5:
                        return BRIDGEH;
                    case 6:
                        return BRIDGEV;
                    default:
                        return console.assert(false, "Unknown tile type " + val);
                }
            });
            var eaglePos = (mapWidth - 2) * (mapHeight - 3) - (mapWidth / 2 | 0);
            _this.map[eaglePos] = EAGLE;
            _this.map[eaglePos + 1] = EAGLE;
            _this.map[eaglePos + mapWidth - 2] = EAGLE;
            _this.map[eaglePos + mapWidth - 1] = EAGLE;

            callback();
        };
        reader.onerror = function () {
            return console.assert(false, "Couldn't load " + levelName + ".tmx");
        };
        reader.send();
    };

    loadLevel(function () {
        var renderTime = Date.now();

        renderTexture(_this.layerGround, _this.textures.ground);
        renderLava();
        renderBridge();
        renderBoard();
        renderEagle();
        renderBrick();
        renderGrass();

        _this.context = canvas.getContext("2d");
        _this.context.drawImage(_this.layerGround.canvas, 0, 0);
        _this.context.drawImage(_this.layerLava.canvas, 0, 0);
        _this.context.drawImage(_this.layerBrick.canvas, 0, 0);
        _this.context.drawImage(_this.layerGrass.canvas, 0, 0);

        console.log("Render time = " + (Date.now() - renderTime));
    });
};
},{"./gener/genTextures":2,"./utils":5}],4:[function(require,module,exports){
"use strict";

var _utils = require("./utils");

var _level = require("./level");

// Size of map 36x20
function calcSizeForCanvas(width, height) {
    var _getSizeMap = (0, _utils.getSizeMap)(),
        mapWidth = _getSizeMap.mapWidth,
        mapHeight = _getSizeMap.mapHeight;

    var aspect = width / height;
    var mapAspect = mapWidth / (mapHeight + 1); // +1 for UI

    if (mapAspect > aspect) {
        return { width: width, height: width / mapAspect };
    }
    return { width: height * mapAspect, height: height };
}

function main() {
    console.assert = function (condition) {
        var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assertion failed";

        if (!condition) {
            console.log(message);
            if (typeof Error !== "undefined") {
                throw new Error(message);
            }
            throw message; // Fallback
        }
    };

    var canvas = document.getElementById("canvas");

    var _calcSizeForCanvas = calcSizeForCanvas(window.innerWidth - 40, window.innerHeight - 40),
        width = _calcSizeForCanvas.width,
        height = _calcSizeForCanvas.height;

    canvas.width = width;
    canvas.height = height;

    var level = new _level.Level("levels/test", canvas);
}
window.addEventListener("load", main);
},{"./level":3,"./utils":5}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rand = rand;
exports.clamp = clamp;
exports.randColor = randColor;
exports.getSizeMap = getSizeMap;
function rand(m, radius) {
    return 2 * radius * Math.random() - radius + m;
}

function clamp(a, min, max) {
    return Math.max(min, Math.min(max, a));
}

function randColor(color) {
    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    var ret = new Array(3);
    for (var i = 0; i < 3; i++) {
        ret[i] = clamp(rand(color[i], radius), 0, 255);
    }return ret;
}

function getSizeMap() {
    var mapWidth = 36;
    var mapHeight = 20;
    mapWidth += 1 + 1; // for board;
    mapHeight += 1 + 1; // for board;
    return { mapWidth: mapWidth, mapHeight: mapHeight };
}
},{}]},{},[4]);
